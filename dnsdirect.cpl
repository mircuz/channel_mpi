!USE rtchecks
SUBROUTINE buildrhs[SUBROUTINE(COMPLEX rhs^,old^(*),unknown,implicit_part,explicit_part) timescheme; 
						POINTER TO ARRAY(*,*,*) OF MOMFLUX VVd; POINTER TO ARRAY(*,*,*) OF VELOCITY Vd] FOLLOWS
SUBROUTINE linsolve(REAL lambda) FOLLOWS
SUBROUTINE deriv(ARRAY(*) OF REAL f0,f1^) FOLLOWS
SUBROUTINE vetaTOuvw FOLLOWS
SUBROUTINE computeflowrate(REAL lambda) FOLLOWS
#include <string.h>
MODULE dnsdirect

INLINE REAL FUNCTION D0(REAL f(*)) = d0(-2)*f(-2)+d0(-1)*f(-1)+d0(0)*f(0)+d0(1)*f(1)+d0(2)*f(2)
INLINE REAL FUNCTION D1(REAL f(*)) = d1(-2)*f(-2)+d1(-1)*f(-1)+d1(0)*f(0)+d1(1)*f(1)+d1(2)*f(2)
INLINE REAL FUNCTION D2(REAL f(*)) = d2(-2)*f(-2)+d2(-1)*f(-1)+d2(0)*f(0)+d2(1)*f(1)+d2(2)*f(2)
INLINE REAL FUNCTION D4(REAL f(*)) = d4(-2)*f(-2)+d4(-1)*f(-1)+d4(0)*f(0)+d4(1)*f(1)+d4(2)*f(2)
INLINE COMPLEX FUNCTION D0(COMPLEX f(*)) = D0(f.REAL)+I*D0(f.IMAG)
INLINE COMPLEX FUNCTION D1(COMPLEX f(*)) = D1(f.REAL)+I*D1(f.IMAG)
INLINE COMPLEX FUNCTION D2(COMPLEX f(*)) = D2(f.REAL)+I*D2(f.IMAG)
INLINE COMPLEX FUNCTION D4(COMPLEX f(*)) = D4(f.REAL)+I*D4(f.IMAG)

!//--------------------------------------------------------------------------------------------------------------------------
SUBROUTINE buildrhs[SUBROUTINE(COMPLEX rhs^,old^(*),unknown,implicit_part,explicit_part) timescheme;
						POINTER TO ARRAY(*,*,*) OF MOMFLUX VVd; POINTER TO ARRAY(*,*,*) OF VELOCITY Vd]
	LOOP FOR ix=ilo TO ihi AND iz=klo TO khi
		alfa=alfa0*ix; beta=beta0*iz
    	ialfa==I*alfa; ibeta==I*beta
   		k2=alfa^2+beta^2
		!// Find old, unknown, implicit and explicit
		LOOP FOR iy= 1 TO ny-1
			WITH derivatives(iy)
      		POINTER TO MOMFLUX VVm2,VVm1,VV0,VV1,VV2              
        	VVm2=VVd(ix,iz,(iy-2));VVm1=VVd(ix,iz,(iy-1));VV0=VVd(ix,iz,(iy));VV1=VVd(ix,iz,(iy+1));VV2=VVd(ix,iz,(iy+2))
			#define D(d,f) d(-2)*VVm2.f+d(-1)*VVm1.f+d(0)*VV0.f+d(1)*VV1.f+d(2)*VV2.f
			WITH Vd(ix,iz,iy+(-2..2)):	
      		D0_uw_=D(d0,uw)
      		D1_uw_=D(d1,uw)
     		rhsu=-ialfa*D(d0,uu)-D(d1,uv)-ibeta*D0_uw_
      		rhsv=-ialfa*D(d0,uv)-D(d1,vv)-ibeta*D(d0,vw)
      		rhsw=-ialfa*D0_uw_-D(d1,vw)-ibeta*D(d0,ww)

			COMPLEX expl = ialfa*[ialfa*D(d1,uu)+D(d2,uv)+ibeta*D1_uw_]+
     					 ibeta*[ialfa*D1_uw_+D(d2,vw)+ibeta*D(d1,ww)]-k2*rhsv
			timescheme{ memrhs(ix,iz,iy).D2v,oldrhs(ix,iz,iy).D2v,D2(v)-k2*D0(v),
												(SUM OS(iy,i)*v(i) FOR ALL i),expl}    

    		IF ix=0 AND iz=0 THEN
      		!// u media conservata in eta.REAL e w media in eta.IMAG
				expl = rhsu.REAL+px+[rhsw.REAL+pz]*I
		   		timescheme{memrhs(0,0,iy).eta,oldrhs(0,0,iy).eta,D0(u.REAL)+D0(w.REAL)*I,
                  										 ni*[D2(u.REAL)]+ni*D2(w.REAL)*I,
							                 !0.5*[D2(u.REAL)]+0.5*D2(w.REAL)*I, !Vittori
                 																	expl} 
      		ELSE
     	 		expl = ibeta*rhsu-ialfa*rhsw
    			timescheme{memrhs(ix,iz,iy).eta,oldrhs(ix,iz,iy).eta,ibeta*D0(u)-ialfa*D0(w),
        		   							(SUM SQ(iy,i)*[ibeta*u(i)-ialfa*w(i)] FOR ALL i),
            	       																	expl} 
      		END IF
		REPEAT		
		!// Substitute eta and D2v inside V 
		LOOP FOR iy=1 TO ny-1
			WITH Vd(ix,iz,iy),memrhs(ix,iz,iy): u=eta; v=D2v		
			!(WRITE "["rank"]  ("ix","iz","iy") V     : " V(ix,iz,iy)
			WRITE "["rank"]  ("ix","iz","iy") oldrhs: " oldrhs(ix,iz,iy)
			WRITE !)
		REPEAT	
	REPEAT
END buildrhs

!//--------------------------------------------------------------------------------------------------------------------------
INLINE FUNCTION D20(ARRAY(*) OF COMPLEX f)=d240(-2)*f(-1)+d240(-1)*f(0)+d240(0)*f(1)+d240(1)*f(2)+d240(2)*f(3)
INLINE FUNCTION D2n(ARRAY(*) OF COMPLEX f)=d24n(-2)*f(ny-3)+d24n(-1)*f(ny-2)+d24n(0)*f(ny-1)+d24n(1)*f(ny)+d24n(2)*f(ny+1)

!//--------------------------------------------------------------------------------------------------------------------------
SUBROUTINE linsolve(REAL lambda)
LOOP FOR ix=ilo TO ihi
	alfa=alfa0*ix; ialfa==I*alfa
  	LOOP FOR iz=klo TO khi
   		beta=beta0*iz; ibeta==I*beta
    	k2=alfa^2+beta^2
    	LOOP FOR iy=1 TO ny-1 AND ALL i WITH derivatives(iy)
    		D2vmat(iz,iy,i)=lambda*[d2(i)-k2*d0(i)]-OS(iy,i)
      		etamat(iz,iy,i)=lambda*d0(i)-SQ(iy,i)
    	REPEAT 
 		!// Lower BCs
		WITH bc0(ix,iz)
    	IF ix=0 AND iz=0 THEN
      		u=u_conv+u0
        	w=~+w_conv+w0
 			v=0; vy=0; eta=u+I*w
      	ELSE
        	vy=-ialfa*u-ibeta*w
        	eta=ibeta*u-ialfa*w
      	END IF
      	v=~-v0bc(0,-2)*vy/v0bc(-1,-2) 
      	applybc_0(D2vmat(iz),v0bc)
      	applybc_0(etamat(iz),eta0bc)
      	V(ix,iz,1).v=~-D2vmat(iz,1,-2)*vy/v0bc(-1,-2)-D2vmat(iz,1,-1)*v/v0bc(0,-1)
      	V(ix,iz,2).v=~-D2vmat(iz,2,-2)*v/v0bc(0,-1)
      	V(ix,iz,1).u=~-etamat(iz,1,-1)*eta/eta0bc(0,-1)          
      	V(ix,iz,2).u=~-etamat(iz,2,-2)*eta/eta0bc(0,-1)

		!// Upper BCs
    	WITH bcn(ix,iz)
      	IF ix=0 AND iz=0 THEN
        	u=u_conv+un
        	w=~+w_conv+wn
			v=0; vy=0; eta=u+I*w 
      	ELSE
        	vy=-ialfa*u-ibeta*w
        	eta=ibeta*u-ialfa*w
      	END IF
      	v=~-vnbc(0)(2)*vy/vnbc(1)(2)
      	applybc_n(D2vmat(iz),vnbc)
      	applybc_n(etamat(iz),etanbc)
      	V(ix,iz,ny-1).v=~-D2vmat(iz,ny-1,2)*vy/vnbc(1,2)-D2vmat(iz,ny-1,1)*v/vnbc(0,1)
      	V(ix,iz,ny-2).v=~-D2vmat(iz,ny-2,2)*v/vnbc(0,1)
      	V(ix,iz,ny-1).u=~-etamat(iz,ny-1,1)*eta/etanbc(0,1)
      	V(ix,iz,ny-2).u=~-etamat(iz,ny-2,2)*eta/etanbc(0,1)   

		!// Solve
    	LUdecomp D2vmat(iz); LUdecomp etamat(iz) 
		D2vmat(iz,1,-2..-1) = 0; 	etamat(iz,1,-2..-1) = 0
		D2vmat(iz,2,-2) = 0;		etamat(iz,2,-2) = 0
		D2vmat(iz,ny-1,1..2)= 0; 	etamat(iz,ny-1,1..2)= 0
		D2vmat(iz,ny-2,2)=0;		etamat(iz,ny-2,2)=0	
    	WITH V(ix,iz,*)
		LeftLUDiv(v.REAL,D2vmat(iz),v.REAL)
		LeftLUDiv(v.IMAG,D2vmat(iz),v.IMAG) 
   	 	LeftLUDiv(u.REAL,etamat(iz),u.REAL)       
    	LeftLUDiv(u.IMAG,etamat(iz),u.IMAG)  

  	REPEAT
  	LOOP FOR ALL iz
    	WITH V(ix,iz,*):
    	v(ny)  =(bcn(ix,iz).v  -SUM v(ny-1+i)*vnbc(0,i) FOR i=-2 TO 0)/vnbc(0,1)
    	v(ny+1)=(bcn(ix,iz).vy -SUM v(ny-1+i)*vnbc(1,i) FOR i=-2 TO 1)/vnbc(1,2)
    	u(ny)=(bcn(ix,iz).eta-SUM u(ny-1+i)*etanbc(0,i) FOR i=-2 TO 0)/etanbc(0,1)
   	 	u(ny+1)=(-SUM u(ny-1+i)*etanbc(1,i) FOR i=-2 TO 1)/etanbc(1,2)
    	v(0) =(bc0(ix,iz).v-SUM v(1+i)*v0bc(0,i) FOR i=0 TO 2)/v0bc(0,-1)
    	v(-1)=(bc0(ix,iz).vy-SUM v(1+i)*v0bc(-1,i) FOR i=-1 TO 2)/v0bc(-1,-2)
    	u(0) =(bc0(ix,iz).eta-SUM u(1+i)*eta0bc(0,i) FOR i=0 TO 2)/eta0bc(0,-1)
    	u(-1)=(-SUM u(1+i)*eta0bc(-1,i) FOR i=-1 TO 2)/eta0bc(-1,-2)
  	REPEAT
REPEAT 
END linsolve

!//--------------------------------------------------------------------------------------------------------------------------
SUBROUTINE deriv(ARRAY(*) OF REAL f0,f1^)
	f1(0)=SUM d140(i)*f0(1+i) FOR i=-2 TO 2
	f1(-1)=SUM d14m1(i)*f0(1+i) FOR i=-2 TO 2
	f1(ny)=SUM d14n(i)*f0(ny-1+i) FOR i=-2 TO 2
	f1(ny+1)=SUM d14np1(i)*f0(ny-1+i) FOR i=-2 TO 2
	DO WITH derivatives(i) f1(i)=D1(f0(i+(*))) FOR i=1 TO ny-1
	WITH derivatives(1): f1(1)=~-(d0(-1)*f1(0)+d0(-2)*f1(-1))
	WITH derivatives(2): f1(2)=~-d0(-2)*f1(0)
	WITH derivatives(ny-1): f1(ny-1)=~-(d0(1)*f1(ny)+d0(2)*f1(ny+1))
	WITH derivatives(ny-2): f1(ny-2)=~-d0(2)*f1(ny)	
	LeftLUDiv(f1,D0mat,f1)
END deriv

!//Remember: eta=+I*beta*u-I*alfa*w----------------------------------------------------------------------------------------- 
SUBROUTINE vetaTOuvw
	LOOP FOR ix=ilo TO ihi AND iz=klo TO khi
		IF ix=0 AND iz=0 THEN WITH V(0,0,*): w.REAL=u.IMAG; u.IMAG=0; w.IMAG=0
	REPEAT LOOP
	LOOP FOR ix=ilo TO ihi 
		alfa=alfa0*ix
		LOOP FOR iz=klo TO khi EXCEPT ix=0 AND iz=0
  			WITH V(ix,iz,*):
  			deriv(v.REAL,w.REAL)
  			deriv(v.IMAG,w.IMAG)
			beta=beta0*iz; k2=alfa^2+beta^2
    		DO temp=I*(alfa*w(iy)-beta*u(iy))/k2
     			w(iy)=I*(beta*w(iy)+alfa*u(iy))/k2 
      			u(iy)=temp
    		FOR ALL iy
		REPEAT
	REPEAT 
END vetaTOuvw

!//--------------------------------------------------------------------------------------------------------------------------
SUBROUTINE computeflowrate(REAL lambda)
  	REAL ucorr(-1..(ny+1))=0	
  	DO ucorr(iy)=1 FOR iy=1 TO ny-1
	LOOP FOR iz=klo TO khi	
		IF iz=0 THEN  
  			LOOP FOR iy=1 TO ny-1 WITH derivatives(iy)
     			etamat(0,iy)=lambda*d0-ni*d2
  			REPEAT 
  			applybc_0(etamat(0),eta0bc)
  			applybc_n(etamat(0),etanbc)
  			LUdecomp etamat(0)
			etamat(0,1,-2..-1) = 0;	etamat(0,2,-2) = 0
			etamat(0,ny-1,1..2)= 0;	etamat(0,ny-2,2)=0
			etamat(0,1,-2..-1) = 0;		etamat(0,2,-2) = 0
			etamat(0,ny-1,1..2)= 0;		etamat(0,ny-2,2)=0
  			LeftLUDiv(ucorr,etamat(0),ucorr) 
			ucorr(ny)  =(-SUM ucorr(ny-1+i)*etanbc(0)(i) FOR i=-2 TO 0)/etanbc(0)(1)
   			ucorr(ny+1)=(-SUM ucorr(ny-1+i)*etanbc(1)(i) FOR i=-2 TO 1)/etanbc(1)(2)
    		ucorr(0) =(-SUM ucorr(1+i)*eta0bc(0)(i) FOR i=0 TO 2)/eta0bc(0)(-1)
    		ucorr(-1)=(-SUM ucorr(1+i)*eta0bc(-1)(i) FOR i=-1 TO 2)/eta0bc(-1)(-2)
			LOOP FOR ix=ilo TO ihi
				IF ix=0 THEN
					STRUCTURE(REAL u,w,uc,wc) fr=0   
  					WITH V(0, 0, *) 
  					DO v(iy)=0 FOR ALL iy
  					yintegr(fr.u, u.REAL)
  					yintegr(fr.w, w.REAL)
  					yintegr(fr.uc, ucorr) 
					px = (1-gamma)*6*ni/fr.u   !Constant Power Input
					!pz = (1-gamma)*6*ni/fr.w   !Constant Power Input
					IF meanflowx # -99 THEN 
    					px=0; corrpx=(meanflowx+u_conv*(ymax-ymin)-fr.u)/fr.uc ! Constant Q
    					u.REAL=~+corrpx*ucorr
						fr.u = meanflowx
  					END IF
  					IF meanflowz # -99 THEN 
    					pz=0; corrpz=(meanflowz+w_conv*(ymax-ymin)-fr.w)/fr.uc  ! Constant Q
    					w.REAL=~+corrpz*ucorr
						fr.w = meanflowz
  					END IF
  					IF meanpx # -99 THEN px = meanpx ! Constant Px
  					IF meanpz # -99 THEN pz = meanpz ! Constant Pz
  					flowx=fr.u-u_conv*(ymax-ymin); flowz=fr.w-w_conv*(ymax-ymin)
     				u1zero=SUM d140(i)*V(0, 0, i+1).u.REAL FOR i=-2 TO 2
     				w1zero=SUM d140(i)*V(0, 0, i+1).w.REAL FOR i=-2 TO 2
				END IF
			REPEAT LOOP
		END IF
  	REPEAT LOOP  
END computeflowrate

END dnsdirect

!// Function to copy data from the structure to C--------------------------------------------------------
SUBROUTINE move_data
	INTEGER counter = 0
	LOOP FOR i=ilo TO ihi
		LOOP FOR k=klo TO khi
			LOOP FOR j=-1 TO ny+1
				U_t[counter]= V(i,k,j).u.REAL;		V_t[counter]= V(i,k,j).v.REAL;		W_t[counter]= V(i,k,j).w.REAL;		INC counter;
				U_t[counter]= V(i,k,j).u.IMAG;		V_t[counter]= V(i,k,j).v.IMAG;		W_t[counter]= V(i,k,j).w.IMAG;		INC counter;
			REPEAT
		REPEAT
	REPEAT 
END move_data 

SUBROUTINE outstats
	<*
	int nx= nx_+1;	int nz= 2*nz_+1;	int ny=ny_+3;		int size= size_; 	int rank = rank_;
/*	int *contiguous_x = (int *) malloc(sizeof(int)*size);
	int *contiguous_y = (int *) malloc(sizeof(int)*size);
	if (( contiguous_x||contiguous_y ) == NULL) {
		perror(".:Error while allocating memory for disk writing operations:.\n");
		abort();
	}
	contiguous_y[rank] = (fz_jhi_-fz_jlo_+1);
	contiguous_x[rank] = (fz_ihi_-fz_ilo_+1); 
	//printf("conty= %d ,contx= %d ,rank=%d ", contiguous_y[rank], contiguous_x[rank], rank);
	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Allgather(&contiguous_y[rank],1,MPI_INT,contiguous_y,1,MPI_INT, MPI_COMM_WORLD);
	MPI_Allgather(&contiguous_x[rank],1,MPI_INT,contiguous_x,1,MPI_INT, MPI_COMM_WORLD);
	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Datatype vector[size], contiguous[size];
	int bytes_stride = sizeof(double)*2*nz*nx;

	for (int i = 0; i < size; i++) {
		MPI_Type_contiguous(2*nz*contiguous_x[i], MPI_DOUBLE, &contiguous[i]);
		MPI_Type_create_hvector(contiguous_y[i], 1, bytes_stride, contiguous[i], &vector[i]);
		MPI_Type_commit(&vector[i]);
	}


for(int i = 0; i < localdim_x_; i++){
		 if (rank==0) printf("U_t_[%d]= %g\t", i, (*(double *)(i*(ssize_t)sizeof(double)+U_t_)) );	
	}

	MPI_File fh;
	char time_str[15], title_u[15]="";
	gcvt (time_, 10, time_str);
	strcat(title_u,time_str);
	strcat(title_u,"_u.bin"); 
	if( chdir("/home/mirco/Scrivania/channel_mpi-master/results") !=0 )
		perror("Error changing folder in outstats routine");
	MPI_Barrier(MPI_COMM_WORLD);
	MPI_File_open(MPI_COMM_WORLD,title_u,MPI_MODE_CREATE|MPI_MODE_WRONLY,MPI_INFO_NULL,&fh);
	MPI_Offset offset = rank*10*sizeof(double);
	MPI_File_set_view (fh , offset , MPI_CHAR, MPI_CHAR, "external32" ,MPI_INFO_NULL);
	char* pippovar[3];
	pippovar[1]="10", pippovar[2]="20", pippovar[0]="1";
	MPI_File_write_all(fh, pippovar[0] , 50, MPI_CHAR, MPI_STATUS_IGNORE);
	MPI_File_close(&fh);
*/
	int NX=16, NY=8, CH_NX=4, CH_NY=2, RANK=2;
	/*HDF5 APIs definitions*/ 		
    hid_t       file_id, dset_id;         /* file and dataset identifiers */
    hid_t       filespace, memspace;      /* file and memory dataspace identifiers */
    hsize_t     dimsf[2];                 /* dataset dimensions */
    hsize_t     chunk_dims[2];            /* chunk dimensions */
    double         *data;                    /* pointer to data buffer to write */
    hsize_t	count[2];	          /* hyperslab selection parameters */
    hsize_t	stride[2];
    hsize_t	block[2];
    hsize_t	offset[2];
    hid_t	plist_id;                 /* property list identifier */
    int         i;
    herr_t	status;
	MPI_Info info  = MPI_INFO_NULL;
	char time_str[15], title[15]="";
	gcvt (time_, 10, time_str);
	strcat(time_str,".h5");
	if( chdir("/home/mirco/Scrivania/channel_mpi-master/results") !=0 )
		perror("Error changing folder in outstats routine");

	/* 
     * Set up file access property list with parallel I/O access
     */
     plist_id = H5Pcreate(H5P_FILE_ACCESS);
     H5Pset_fapl_mpio(plist_id, MPI_COMM_WORLD, info);

    /*
     * Create a new file collectively and release property list identifier.
     */
    file_id = H5Fcreate(time_str, H5F_ACC_TRUNC, H5P_DEFAULT, plist_id);
    H5Pclose(plist_id);
   

    /*
     * Create the dataspace for the dataset.
     */
    dimsf[0] = nx;
    dimsf[1] = nz;
    chunk_dims[0] = y_ihi_-y_ilo_+1;   
    chunk_dims[1] = y_khi_-y_klo_+1;   
    filespace = H5Screate_simple(RANK, dimsf, NULL); 
    memspace  = H5Screate_simple(RANK, chunk_dims, NULL); 

    /*
     * Create chunked dataset.
     */
    plist_id = H5Pcreate(H5P_DATASET_CREATE);
    H5Pset_chunk(plist_id, RANK, chunk_dims);
    dset_id = H5Dcreate(file_id, "Velocity", H5T_IEEE_F64LE, filespace,
			H5P_DEFAULT, plist_id, H5P_DEFAULT);
    H5Pclose(plist_id);
    H5Sclose(filespace);

    /* 
     * Each process defines dataset in memory and writes it to the hyperslab
     * in the file.
     */
    count[0] = 1;
    count[1] = 1 ;
    stride[0] = 1;
    stride[1] = 1;
    block[0] = chunk_dims[0];
    block[1] = chunk_dims[1];
	offset[0]= y_ilo_;
	offset[1]= y_klo_;
  /*  if(rank == 0) {
       offset[0] = 0;
       offset[1] = 0;
    } 
    if(rank == 1) {
       offset[0] = 0;
       offset[1] = chunk_dims[1];
    }
    if(rank == 2) {
       offset[0] = chunk_dims[0];
       offset[1] = 0;
    } 
    if(rank == 3) {
       offset[0] = chunk_dims[0];
       offset[1] = chunk_dims[1];
    } */

    /*
     * Select hyperslab in the file.
     */
    filespace = H5Dget_space(dset_id);
    status = H5Sselect_hyperslab(filespace, H5S_SELECT_SET, offset, stride, count, block);

    /*
     * Initialize data buffer 
     */
    data = (double *) malloc(sizeof(double)*chunk_dims[0]*chunk_dims[1]);
    for (i=0; i < (int)chunk_dims[0]*chunk_dims[1]; i++) {
        data[i] = rank + 1.2;
    }

    /*
     * Create property list for collective dataset write.
     */
    plist_id = H5Pcreate(H5P_DATASET_XFER);
    H5Pset_dxpl_mpio(plist_id, H5FD_MPIO_COLLECTIVE);
    
    status = H5Dwrite(dset_id, H5T_IEEE_F64LE, memspace, filespace,
		      plist_id, data);		//&(U_t_[0]) for my purpose
    free(data);

    /*
     * Close/release resources.
     */
    H5Dclose(dset_id);
    H5Sclose(filespace);
    H5Sclose(memspace);
    H5Pclose(plist_id);
    H5Fclose(file_id);

	*>
END outstats
