!USE rtchecks
SUBROUTINE buildrhs[SUBROUTINE(COMPLEX rhs^,old^(*),unknown,implicit_part,explicit_part) timescheme; 
						POINTER TO ARRAY(*,*,*) OF MOMFLUX VVd; POINTER TO ARRAY(*,*,*) OF VELOCITY Vd] FOLLOWS
SUBROUTINE linsolve(REAL lambda) FOLLOWS
SUBROUTINE deriv(ARRAY(*) OF REAL f0,f1^) FOLLOWS
SUBROUTINE vetaTOuvw FOLLOWS
SUBROUTINE computeflowrate(REAL lambda) FOLLOWS
#include <string.h>
MODULE dnsdirect

INLINE REAL FUNCTION D0(REAL f(*)) = d0(-2)*f(-2)+d0(-1)*f(-1)+d0(0)*f(0)+d0(1)*f(1)+d0(2)*f(2)
INLINE REAL FUNCTION D1(REAL f(*)) = d1(-2)*f(-2)+d1(-1)*f(-1)+d1(0)*f(0)+d1(1)*f(1)+d1(2)*f(2)
INLINE REAL FUNCTION D2(REAL f(*)) = d2(-2)*f(-2)+d2(-1)*f(-1)+d2(0)*f(0)+d2(1)*f(1)+d2(2)*f(2)
INLINE REAL FUNCTION D4(REAL f(*)) = d4(-2)*f(-2)+d4(-1)*f(-1)+d4(0)*f(0)+d4(1)*f(1)+d4(2)*f(2)
INLINE COMPLEX FUNCTION D0(COMPLEX f(*)) = D0(f.REAL)+I*D0(f.IMAG)
INLINE COMPLEX FUNCTION D1(COMPLEX f(*)) = D1(f.REAL)+I*D1(f.IMAG)
INLINE COMPLEX FUNCTION D2(COMPLEX f(*)) = D2(f.REAL)+I*D2(f.IMAG)
INLINE COMPLEX FUNCTION D4(COMPLEX f(*)) = D4(f.REAL)+I*D4(f.IMAG)

!//--------------------------------------------------------------------------------------------------------------------------
SUBROUTINE buildrhs[SUBROUTINE(COMPLEX rhs^,old^(*),unknown,implicit_part,explicit_part) timescheme;
						POINTER TO ARRAY(*,*,*) OF MOMFLUX VVd; POINTER TO ARRAY(*,*,*) OF VELOCITY Vd]
	LOOP FOR ix=ilo TO ihi AND iz=klo TO khi
		alfa=alfa0*ix; beta=beta0*iz
    	ialfa==I*alfa; ibeta==I*beta
   		k2=alfa^2+beta^2
		!// Find old, unknown, implicit and explicit
		LOOP FOR iy= 1 TO ny-1
			WITH derivatives(iy)
      		POINTER TO MOMFLUX VVm2,VVm1,VV0,VV1,VV2              
        	VVm2=VVd(ix,iz,(iy-2));VVm1=VVd(ix,iz,(iy-1));VV0=VVd(ix,iz,(iy));VV1=VVd(ix,iz,(iy+1));VV2=VVd(ix,iz,(iy+2))
		!	IF rank=0 THEN WRITE "("ix","iz","iy"): " VVm2.uu, VVm1.uu, VV0.uu, VV1.uu, VV2.uu
			#define D(d,f) d(-2)*VVm2.f+d(-1)*VVm1.f+d(0)*VV0.f+d(1)*VV1.f+d(2)*VV2.f
			WITH Vd(ix,iz,iy+(-2..2)):	
      		D0_uw_=D(d0,uw)
      		D1_uw_=D(d1,uw)
     		rhsu=-ialfa*D(d0,uu)-D(d1,uv)-ibeta*D0_uw_
      		rhsv=-ialfa*D(d0,uv)-D(d1,vv)-ibeta*D(d0,vw)
      		rhsw=-ialfa*D0_uw_-D(d1,vw)-ibeta*D(d0,ww)

			COMPLEX expl = ialfa*[ialfa*D(d1,uu)+D(d2,uv)+ibeta*D1_uw_]+
     					 ibeta*[ialfa*D1_uw_+D(d2,vw)+ibeta*D(d1,ww)]-k2*rhsv
			timescheme{ memrhs(ix,iz,iy).D2v,oldrhs(ix,iz,iy).D2v,D2(v)-k2*D0(v),
												(SUM OS(iy,i)*v(i) FOR ALL i),expl}    

    		IF ix=0 AND iz=0 THEN
      		!// u media conservata in eta.REAL e w media in eta.IMAG
				expl = rhsu.REAL+px+[rhsw.REAL+pz]*I
		   		timescheme{memrhs(0,0,iy).eta,oldrhs(0,0,iy).eta,D0(u.REAL)+D0(w.REAL)*I,
                  										 ni*[D2(u.REAL)]+ni*D2(w.REAL)*I,
							                 !0.5*[D2(u.REAL)]+0.5*D2(w.REAL)*I, !Vittori
                 																	expl} 
      		ELSE
     	 		expl = ibeta*rhsu-ialfa*rhsw
    			timescheme{memrhs(ix,iz,iy).eta,oldrhs(ix,iz,iy).eta,ibeta*D0(u)-ialfa*D0(w),
        		   							(SUM SQ(iy,i)*[ibeta*u(i)-ialfa*w(i)] FOR ALL i),
            	       																	expl} 
      		END IF
		REPEAT		
		!// Substitute eta and D2v inside V 
		LOOP FOR iy=1 TO ny-1
			WITH Vd(ix,iz,iy),memrhs(ix,iz,iy): u=eta; v=D2v		
			!(WRITE "["rank"]  ("ix","iz","iy") V     : " V(ix,iz,iy)
			WRITE "["rank"]  ("ix","iz","iy") oldrhs: " oldrhs(ix,iz,iy)
			WRITE !)
		REPEAT	
	REPEAT
END buildrhs

!//--------------------------------------------------------------------------------------------------------------------------
INLINE FUNCTION D20(ARRAY(*) OF COMPLEX f)=d240(-2)*f(-1)+d240(-1)*f(0)+d240(0)*f(1)+d240(1)*f(2)+d240(2)*f(3)
INLINE FUNCTION D2n(ARRAY(*) OF COMPLEX f)=d24n(-2)*f(ny-3)+d24n(-1)*f(ny-2)+d24n(0)*f(ny-1)+d24n(1)*f(ny)+d24n(2)*f(ny+1)

!//--------------------------------------------------------------------------------------------------------------------------
SUBROUTINE linsolve(REAL lambda)
LOOP FOR ix=ilo TO ihi
	alfa=alfa0*ix; ialfa==I*alfa
  	LOOP FOR iz=klo TO khi
   		beta=beta0*iz; ibeta==I*beta
    	k2=alfa^2+beta^2
    	LOOP FOR iy=1 TO ny-1 AND ALL i WITH derivatives(iy)
    		D2vmat(iz,iy,i)=lambda*[d2(i)-k2*d0(i)]-OS(iy,i)
      		etamat(iz,iy,i)=lambda*d0(i)-SQ(iy,i)
    	REPEAT 
 		!// Lower BCs
		WITH bc0(ix,iz)
    	IF ix=0 AND iz=0 THEN
      		u=u_conv+u0
        	w=~+w_conv+w0
 			v=0; vy=0; eta=u+I*w
      	ELSE
        	vy=-ialfa*u-ibeta*w
        	eta=ibeta*u-ialfa*w
      	END IF
      	v=~-v0bc(0,-2)*vy/v0bc(-1,-2) 
      	applybc_0(D2vmat(iz),v0bc)
      	applybc_0(etamat(iz),eta0bc)
      	V(ix,iz,1).v=~-D2vmat(iz,1,-2)*vy/v0bc(-1,-2)-D2vmat(iz,1,-1)*v/v0bc(0,-1)
      	V(ix,iz,2).v=~-D2vmat(iz,2,-2)*v/v0bc(0,-1)
      	V(ix,iz,1).u=~-etamat(iz,1,-1)*eta/eta0bc(0,-1)          
      	V(ix,iz,2).u=~-etamat(iz,2,-2)*eta/eta0bc(0,-1)

		!// Upper BCs
    	WITH bcn(ix,iz)
      	IF ix=0 AND iz=0 THEN
        	u=u_conv+un
        	w=~+w_conv+wn
			v=0; vy=0; eta=u+I*w 
      	ELSE
        	vy=-ialfa*u-ibeta*w
        	eta=ibeta*u-ialfa*w
      	END IF
      	v=~-vnbc(0)(2)*vy/vnbc(1)(2)
      	applybc_n(D2vmat(iz),vnbc)
      	applybc_n(etamat(iz),etanbc)
      	V(ix,iz,ny-1).v=~-D2vmat(iz,ny-1,2)*vy/vnbc(1,2)-D2vmat(iz,ny-1,1)*v/vnbc(0,1)
      	V(ix,iz,ny-2).v=~-D2vmat(iz,ny-2,2)*v/vnbc(0,1)
      	V(ix,iz,ny-1).u=~-etamat(iz,ny-1,1)*eta/etanbc(0,1)
      	V(ix,iz,ny-2).u=~-etamat(iz,ny-2,2)*eta/etanbc(0,1)   

		!// Solve
    	LUdecomp D2vmat(iz); LUdecomp etamat(iz) 
		D2vmat(iz,1,-2..-1) = 0; 	etamat(iz,1,-2..-1) = 0
		D2vmat(iz,2,-2) = 0;		etamat(iz,2,-2) = 0
		D2vmat(iz,ny-1,1..2)= 0; 	etamat(iz,ny-1,1..2)= 0
		D2vmat(iz,ny-2,2)=0;		etamat(iz,ny-2,2)=0	
    	WITH V(ix,iz,*)
		LeftLUDiv(v.REAL,D2vmat(iz),v.REAL)
		LeftLUDiv(v.IMAG,D2vmat(iz),v.IMAG) 
   	 	LeftLUDiv(u.REAL,etamat(iz),u.REAL)       
    	LeftLUDiv(u.IMAG,etamat(iz),u.IMAG)  

  	REPEAT
  	LOOP FOR ALL iz
    	WITH V(ix,iz,*):
    	v(ny)  =(bcn(ix,iz).v  -SUM v(ny-1+i)*vnbc(0,i) FOR i=-2 TO 0)/vnbc(0,1)
    	v(ny+1)=(bcn(ix,iz).vy -SUM v(ny-1+i)*vnbc(1,i) FOR i=-2 TO 1)/vnbc(1,2)
    	u(ny)=(bcn(ix,iz).eta-SUM u(ny-1+i)*etanbc(0,i) FOR i=-2 TO 0)/etanbc(0,1)
   	 	u(ny+1)=(-SUM u(ny-1+i)*etanbc(1,i) FOR i=-2 TO 1)/etanbc(1,2)
    	v(0) =(bc0(ix,iz).v-SUM v(1+i)*v0bc(0,i) FOR i=0 TO 2)/v0bc(0,-1)
    	v(-1)=(bc0(ix,iz).vy-SUM v(1+i)*v0bc(-1,i) FOR i=-1 TO 2)/v0bc(-1,-2)
    	u(0) =(bc0(ix,iz).eta-SUM u(1+i)*eta0bc(0,i) FOR i=0 TO 2)/eta0bc(0,-1)
    	u(-1)=(-SUM u(1+i)*eta0bc(-1,i) FOR i=-1 TO 2)/eta0bc(-1,-2)
  	REPEAT
REPEAT 
END linsolve

!//--------------------------------------------------------------------------------------------------------------------------
SUBROUTINE deriv(ARRAY(*) OF REAL f0,f1^)
	f1(0)=SUM d140(i)*f0(1+i) FOR i=-2 TO 2
	f1(-1)=SUM d14m1(i)*f0(1+i) FOR i=-2 TO 2
	f1(ny)=SUM d14n(i)*f0(ny-1+i) FOR i=-2 TO 2
	f1(ny+1)=SUM d14np1(i)*f0(ny-1+i) FOR i=-2 TO 2
	DO WITH derivatives(i) f1(i)=D1(f0(i+(*))) FOR i=1 TO ny-1
	WITH derivatives(1): f1(1)=~-(d0(-1)*f1(0)+d0(-2)*f1(-1))
	WITH derivatives(2): f1(2)=~-d0(-2)*f1(0)
	WITH derivatives(ny-1): f1(ny-1)=~-(d0(1)*f1(ny)+d0(2)*f1(ny+1))
	WITH derivatives(ny-2): f1(ny-2)=~-d0(2)*f1(ny)	
	LeftLUDiv(f1,D0mat,f1)
END deriv

!//Remember: eta=+I*beta*u-I*alfa*w----------------------------------------------------------------------------------------- 
SUBROUTINE vetaTOuvw
	LOOP FOR ix=ilo TO ihi AND iz=klo TO khi
		IF ix=0 AND iz=0 THEN WITH V(0,0,*): w.REAL=u.IMAG; u.IMAG=0; w.IMAG=0
	REPEAT LOOP
	LOOP FOR ix=ilo TO ihi 
		alfa=alfa0*ix
		LOOP FOR iz=klo TO khi EXCEPT ix=0 AND iz=0
  			WITH V(ix,iz,*):
  			deriv(v.REAL,w.REAL)
  			deriv(v.IMAG,w.IMAG)
			beta=beta0*iz; k2=alfa^2+beta^2
    		DO temp=I*(alfa*w(iy)-beta*u(iy))/k2
     			w(iy)=I*(beta*w(iy)+alfa*u(iy))/k2 
      			u(iy)=temp
    		FOR ALL iy
		REPEAT
	REPEAT 
END vetaTOuvw

!//--------------------------------------------------------------------------------------------------------------------------
SUBROUTINE computeflowrate(REAL lambda)
  	REAL ucorr(-1..(ny+1))=0	
  	DO ucorr(iy)=1 FOR iy=1 TO ny-1
	LOOP FOR iz=klo TO khi	
		IF iz=0 THEN  
  			LOOP FOR iy=1 TO ny-1 WITH derivatives(iy)
     			etamat(0,iy)=lambda*d0-ni*d2
  			REPEAT 
  			applybc_0(etamat(0),eta0bc)
  			applybc_n(etamat(0),etanbc)
  			LUdecomp etamat(0)
			etamat(0,1,-2..-1) = 0;	etamat(0,2,-2) = 0
			etamat(0,ny-1,1..2)= 0;	etamat(0,ny-2,2)=0
			etamat(0,1,-2..-1) = 0;		etamat(0,2,-2) = 0
			etamat(0,ny-1,1..2)= 0;		etamat(0,ny-2,2)=0
  			LeftLUDiv(ucorr,etamat(0),ucorr) 
			ucorr(ny)  =(-SUM ucorr(ny-1+i)*etanbc(0)(i) FOR i=-2 TO 0)/etanbc(0)(1)
   			ucorr(ny+1)=(-SUM ucorr(ny-1+i)*etanbc(1)(i) FOR i=-2 TO 1)/etanbc(1)(2)
    		ucorr(0) =(-SUM ucorr(1+i)*eta0bc(0)(i) FOR i=0 TO 2)/eta0bc(0)(-1)
    		ucorr(-1)=(-SUM ucorr(1+i)*eta0bc(-1)(i) FOR i=-1 TO 2)/eta0bc(-1)(-2)
			LOOP FOR ix=ilo TO ihi
				IF ix=0 THEN
					STRUCTURE(REAL u,w,uc,wc) fr=0   
  					WITH V(0, 0, *) 
  					DO v(iy)=0 FOR ALL iy
  					yintegr(fr.u, u.REAL)
  					yintegr(fr.w, w.REAL)
  					yintegr(fr.uc, ucorr) 
					px = (1-gamma)*6*ni/fr.u   !Constant Power Input
					!pz = (1-gamma)*6*ni/fr.w   !Constant Power Input
					IF meanflowx # -99 THEN 
    					px=0; corrpx=(meanflowx+u_conv*(ymax-ymin)-fr.u)/fr.uc ! Constant Q
    					u.REAL=~+corrpx*ucorr
						fr.u = meanflowx
  					END IF
  					IF meanflowz # -99 THEN 
    					pz=0; corrpz=(meanflowz+w_conv*(ymax-ymin)-fr.w)/fr.uc  ! Constant Q
    					w.REAL=~+corrpz*ucorr
						fr.w = meanflowz
  					END IF
  					IF meanpx # -99 THEN px = meanpx ! Constant Px
  					IF meanpz # -99 THEN pz = meanpz ! Constant Pz
  					flowx=fr.u-u_conv*(ymax-ymin); flowz=fr.w-w_conv*(ymax-ymin)
     				u1zero=SUM d140(i)*V(0, 0, i+1).u.REAL FOR i=-2 TO 2
     				w1zero=SUM d140(i)*V(0, 0, i+1).w.REAL FOR i=-2 TO 2
				END IF
			REPEAT LOOP
		END IF
  	REPEAT LOOP  
END computeflowrate

END dnsdirect

!// Function to copy data from the structure to C--------------------------------------------------------
SUBROUTINE move_data
	INTEGER counter = 0
	LOOP FOR i=ilo TO ihi
		LOOP FOR k=klo TO khi
			LOOP FOR j=-1 TO ny+1
				!WRITE "("i","k","j")   " V(i,k,j)
				U_t[counter]= V(i,k,j).u.REAL;		V_t[counter]= V(i,k,j).v.REAL;		W_t[counter]= V(i,k,j).w.REAL;		INC counter;
				U_t[counter]= V(i,k,j).u.IMAG;		V_t[counter]= V(i,k,j).v.IMAG;		W_t[counter]= V(i,k,j).w.IMAG;		INC counter;
			REPEAT
		REPEAT
	REPEAT 	
END move_data 
