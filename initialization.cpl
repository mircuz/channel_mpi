WRITE
<*
  	/************************************************************************************************
	 * 													      										*
	 * 				Determine data for Pencil Decomposition and Scatter in MPI Space				*
	 * 													      										*
	 ************************************************************************************************
											     	  					  Author: Dr. Mirco Meazzo */
  
  #include "fft_support.h"
  int nfast,nmid,nslow, nx,ny,nz;
  nx = nx_+1;		ny = ny_+3;	nz = nz_*2+1;

  int nxd_AA = (nx*3)/2;
  // fftFitting
  int nxd = 4; int nzd = 4;
  while ( nxd < nxd_AA ) {
	  nxd = nxd*2;
  }
  while ( nzd < nz ) {
	  nzd = nzd*2;
  }

  // Length of the array along directions
  int i_length = nxd;
  int j_length = ny;
  int k_length = nzd;

  // TOTAL Modes
  nfast = nxd;
  nmid = ny;
  nslow = nzd;

  // Algorithm to factor Nprocs into roughly cube roots
  int npfast,npmid,npslow;
  npfast= 1;
  int npmidslow = size / npfast;
  npmid = (int) sqrt(npmidslow);
  while (npmid < npmidslow) {
    if (npmidslow % npmid == 0) break;
    npmid++;
  }
  npslow = size / npfast / npmid;


  if (rank == 0) {
  	  printf("\n========================================================================================\n"
  			  "\t2D FFT with %dx%dx%d total modes (%d,%d,%d) on %d procs, %dx%dx%d grid\t\n"
  			"========================================================================================\n\n",
  			  nfast,nmid,nslow,nx,ny,nz,size,npfast,npmid,npslow);
    }

  if ((ny/npmid) < 1) {
	  perror("\n\n\nInvalid Y Grid decomposition\nAborting simulation...\n\n\n");
	  abort();
  }
  if ((nz/npslow) < 1) {
 	  perror("\n\n\nInvalid Z Grid decomposition\nAborting simulation...\n\n\n");
 	  abort();
   }

  /******************************************** Remap Variables *******************************************/
  // partitioning in x-pencil
  int ipfast = rank % npfast;
  int ipmid = (rank/npfast) % npmid;
  int ipslow = rank / (npfast*npmid);
  int in_ilo, in_ihi, in_jlo, in_jhi, in_klo, in_khi;

  in_ilo = (int) 1.0*ipfast*nfast/npfast;						// I fast
  in_ihi = (int) 1.0*(ipfast+1)*nfast/npfast - 1;
  in_jlo = (int) 1.0*ipmid*nmid/npmid;							// J med
  in_jhi = (int) 1.0*(ipmid+1)*nmid/npmid - 1;
  in_klo = (int) 1.0*ipslow*nslow/npslow;						// K slow
  in_khi = (int) 1.0*(ipslow+1)*nslow/npslow - 1;

  printf("[X-PENCIL] (i,j,k order)\t"
		  "On rank %d the coordinates are: "
		  "(%d,%d,%d) -> (%d,%d,%d)\n", rank, in_ilo, in_jlo, in_klo, in_ihi, in_jhi, in_khi );

  nfast = nzd;
  nmid = nxd;
  nslow = ny;

  // partitioning in z-pencil
  int out_klo = (int) 1.0*ipfast*nfast/npfast;					// K fast
  int out_khi = (int) 1.0*(ipfast+1)*nfast/npfast - 1;
  int out_ilo = (int) 1.0*ipmid*nmid/npmid;						// I med
  int out_ihi = (int) 1.0*(ipmid+1)*nmid/npmid - 1;
  int out_jlo = (int) 1.0*ipslow*nslow/npslow;					// J slow
  int out_jhi = (int) 1.0*(ipslow+1)*nslow/npslow - 1;

  printf("[Z-PENCIL] (k,i,j order)\t"
		  "On rank %d the coordinates are: "
		  "(%d,%d,%d) -> (%d,%d,%d)\n", rank, out_ilo, out_jlo, out_klo, out_ihi, out_jhi, out_khi );

  void *remap_zpencil, *remap_xpencil, *remap_ypencil;
  int nqty, permute, memoryflag, sendsize, recvsize;
  nqty = 2;			// Use couples of real numbers per grid point
  permute = 2;  		// From x-contiguous to z-contiguous arrays
  memoryflag = 1;		// Self-allocate the buffers


  /******************************************* Size Variables ******************************************/
  int insize = (in_ihi-in_ilo+1) * (in_jhi-in_jlo+1) * (in_khi-in_klo+1);
  int outsize = (out_ihi-out_ilo+1) * (out_jhi-out_jlo+1) * (out_khi-out_klo+1);
  int remapsize = (insize > outsize) ? insize : outsize;
  int elem_per_proc = insize*2;

  // Alloc the arrays
  int* displs = (int *)malloc(size*sizeof(int));
  int* scounts = (int *)malloc(size*sizeof(int));
  int* receive = (int *)malloc(size*sizeof(int));
  int* displs_gather = (int *)malloc(size*sizeof(int));
  int* scounts_gather = (int *)malloc(size*sizeof(int));
  int* receive_gather = (int *)malloc(size*sizeof(int));

  // Setup matrix
  int *modes_per_proc = (int *) malloc(sizeof(int)*size);
  modes_per_proc[rank] = (in_jhi-in_jlo+1) * (in_khi-in_klo+1);
  MPI_Allgather(&modes_per_proc[rank],1,MPI_INT,modes_per_proc,1,MPI_INT, MPI_COMM_WORLD);
  // Scattering & Gathering parameters
  int offset=0;
  for (int i=0; i<size; ++i) {
  	  scounts[i] = modes_per_proc[i]*nxd*2;
  	  receive[i] = scounts[i];
  	  displs[i] = offset;
  	  offset += scounts[i];
  }


  /********************************** Setup asymetric factors for scattering **********************************/
  // Setup matrix
  int modes_per_proc_scat[size], displs_scat[size], scounts_scat[size], receive_scat[size];
  for (int i = 0; i < size; i++){
	  modes_per_proc_scat[i] = 0;
	  displs_scat[i] = 0;
  }
  // Set modes per processor
  cores_handler( nx*nz, size, modes_per_proc_scat);
  // Scattering parameters
  offset=0;
  for (int i=0; i<size; ++i) {
	  scounts_scat[i] = modes_per_proc_scat[i]*ny*2;
	  receive_scat[i] = scounts_scat[i];
  	  displs_scat[i] = offset ;
  	  offset += modes_per_proc_scat[i] *ny*2;
  }
  //printf("modes_ proc %d on rank %d\n", modes_per_proc[rank], rank);
  //printf("scoutn %d & disps %d on rank %d\n", scounts[rank], displs[rank], rank);


  /******************************************** Memory Alloc *******************************************/
  FFT_SCALAR *u = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *v = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *w = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *u_read = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *v_read = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *w_read = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *uu = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *uv = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *vv = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *vw = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *ww = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *uw = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *sendbuf = (FFT_SCALAR *) malloc(sendsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *recvbuf = (FFT_SCALAR *) malloc(recvsize*sizeof(FFT_SCALAR)*2);

  if ((u||u_read||v||v_read||w||w_read||uu||uv||vv||vw||ww||uw||sendbuf||recvbuf) == NULL) {
	  perror(".:Error while allocating memory for remapping variables:.\n");
	  abort();
  }

  // Declare variables, on all procs, needed to Scatter data
  FFT_SCALAR *V, *U, *W, *U_read, *V_read, *W_read;

  // Allocate mememory needed to Scatter data, only on the broadcaster
  // U
  U_read = (FFT_SCALAR*) malloc( nx*ny*nz*2* sizeof(FFT_SCALAR));
  U = (FFT_SCALAR*) malloc( nxd*ny*nzd*2* sizeof(FFT_SCALAR));
  if( (U||U_read) == NULL) {
	  perror(".:Error while allocatin broadcaster memory U:.\n");
	  abort();
  }
  if (rank == 0) {
	  read_data(nx, ny, nz, U_read, "u.dat");
  	  apply_AA(nx, ny, nz, nxd, nzd, U, U_read);
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nxd, ny, nzd, U, u, 1);
  MPI_Barrier(MPI_COMM_WORLD);
  free(U);
  if (rank == 0) transpose_on_rank0( nx, ny, nz, U_read);
  MPI_Barrier(MPI_COMM_WORLD);
  MPI_Scatterv(U_read, scounts_scat, displs_scat, MPI_DOUBLE, u_read, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if(rank == 0) free(U_read);
  MPI_Barrier(MPI_COMM_WORLD);

  //V
  V_read = (FFT_SCALAR*) malloc( nx*ny*nz*2* sizeof(FFT_SCALAR));
  V = (FFT_SCALAR*) malloc( nxd*ny*nzd*2* sizeof(FFT_SCALAR));
  if( (V||V_read) == NULL) {
	  perror(".:Error while allocating broadcaster memory V:.\n");
	  abort();
  }
  if (rank == 0){
  	  read_data(nx, ny, nz, V_read, "v.dat");
  	  apply_AA(nx, ny, nz, nxd, nzd, V, V_read);
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nxd, ny, nzd, V, v, 1);
  MPI_Barrier(MPI_COMM_WORLD);
  free(V);
  if (rank == 0) transpose_on_rank0( nx, ny, nz, V_read);
  MPI_Barrier(MPI_COMM_WORLD);
  MPI_Scatterv(V_read, scounts_scat, displs_scat, MPI_DOUBLE, v_read, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if(rank == 0) free(V_read);
  MPI_Barrier(MPI_COMM_WORLD);

  //W
  W_read = (FFT_SCALAR*) malloc( nx*ny*nz*2* sizeof(FFT_SCALAR));
  W = (FFT_SCALAR*) malloc( nxd*ny*nzd*2* sizeof(FFT_SCALAR));
  if( (W||W_read) == NULL) {
	  perror(".:Error while allocating broadcaster memory W:.\n");
	  abort();
  }
  if (rank == 0){
  	  read_data(nx, ny, nz, W_read, "w.dat");
   	  apply_AA(nx, ny, nz, nxd, nzd, W, W_read);
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nxd, ny, nzd, W, w, 1);
  MPI_Barrier(MPI_COMM_WORLD);
  free(W);
  if (rank == 0) transpose_on_rank0( nx, ny, nz, W_read);
  MPI_Barrier(MPI_COMM_WORLD);
  MPI_Scatterv(W_read, scounts_scat, displs_scat, MPI_DOUBLE, w_read, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if(rank == 0) free(W_read);
  MPI_Barrier(MPI_COMM_WORLD);

*>
