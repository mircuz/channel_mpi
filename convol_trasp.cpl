WRITE

<*
  	/**************************************************************************************************************
	 * 													      *													  *
	 * 				2D FFT with Pencil Decomposition in MPI Space	   			      *
	 * 													      *														  *
	 **************************************************************************************************************
											     Author: Dr. Mirco Meazzo */
  #include "remap3d_wrap.h"    // To perform 3D remapping
  #include "fft_support.h"

  int nfast,nmid,nslow, nx,ny,nz;
  nx = nx_;		ny = ny_;	nz = nz_*2+1;

  int nxd_AA = (nx*3)/2;
  // fftFitting
  int nxd = 4; int nzd = 4;
  while ( nxd < nxd_AA ) {
	  nxd = nxd*2;
  }
  while ( nzd < nz ) {
	  nzd = nzd*2;
  }

  // Length of the array along directions
  int i_length = nxd;
  int j_length = ny;
  int k_length = nzd;

  // TOTAL Modes
  nfast = nxd;
  nmid = ny;
  nslow = nzd;

  // Algorithm to factor Nprocs into roughly cube roots
  int npfast,npmid,npslow;
  npfast= 1;
  int npmidslow = size / npfast;
  npmid = (int) sqrt(npmidslow);
  while (npmid < npmidslow) {
    if (npmidslow % npmid == 0) break;
    npmid++;
  }
  npslow = size / npfast / npmid;


  if (rank == 0) {
  	  printf("\n========================================================================================\n"
  			  "\t2D FFT with %dx%dx%d total modes (%d,%d,%d) on %d procs, %dx%dx%d grid\t\n"
  			"========================================================================================\n\n",
  			  nfast,nmid,nslow,nx,ny,nz,size,npfast,npmid,npslow);
    }

  if ((ny/npmid) < 1) {
	  perror("\n\n\nInvalid Y Grid decomposition\nAborting simulation...\n\n\n");
	  abort();
  }
  if ((nz/npslow) < 1) {
 	  perror("\n\n\nInvalid Z Grid decomposition\nAborting simulation...\n\n\n");
 	  abort();
   }

  /******************************************** Remap Variables *******************************************/
  // partitioning in x-pencil
  int ipfast = rank % npfast;
  int ipmid = (rank/npfast) % npmid;
  int ipslow = rank / (npfast*npmid);
  int in_ilo, in_ihi, in_jlo, in_jhi, in_klo, in_khi;

  in_ilo = (int) 1.0*ipfast*nfast/npfast;						// I fast
  in_ihi = (int) 1.0*(ipfast+1)*nfast/npfast - 1;
  in_jlo = (int) 1.0*ipmid*nmid/npmid;							// J med
  in_jhi = (int) 1.0*(ipmid+1)*nmid/npmid - 1;
  in_klo = (int) 1.0*ipslow*nslow/npslow;						// K slow
  in_khi = (int) 1.0*(ipslow+1)*nslow/npslow - 1;

  printf("[X-PENCIL] (i,j,k order)\t"
		  "On rank %d the coordinates are: "
		  "(%d,%d,%d) -> (%d,%d,%d)\n", rank, in_ilo, in_jlo, in_klo, in_ihi, in_jhi, in_khi );

  nfast = nzd;
  nmid = nxd;
  nslow = ny;

  // partitioning in z-pencil
  int out_klo = (int) 1.0*ipfast*nfast/npfast;					// K fast
  int out_khi = (int) 1.0*(ipfast+1)*nfast/npfast - 1;
  int out_ilo = (int) 1.0*ipmid*nmid/npmid;						// I med
  int out_ihi = (int) 1.0*(ipmid+1)*nmid/npmid - 1;
  int out_jlo = (int) 1.0*ipslow*nslow/npslow;					// J slow
  int out_jhi = (int) 1.0*(ipslow+1)*nslow/npslow - 1;

  printf("[Z-PENCIL] (k,i,j order)\t"
		  "On rank %d the coordinates are: "
		  "(%d,%d,%d) -> (%d,%d,%d)\n", rank, out_ilo, out_jlo, out_klo, out_ihi, out_jhi, out_khi );

  void *remap_zpencil, *remap_xpencil, *remap_ypencil;
  int nqty, permute, memoryflag, sendsize, recvsize;
  nqty = 2;			// Use couples of real numbers per grid point
  permute = 2;  		// From x-contiguous to z-contiguous arrays
  memoryflag = 1;		// Self-allocate the buffers


  /******************************************* Size Variables ******************************************/
  int insize = (in_ihi-in_ilo+1) * (in_jhi-in_jlo+1) * (in_khi-in_klo+1);
  int outsize = (out_ihi-out_ilo+1) * (out_jhi-out_jlo+1) * (out_khi-out_klo+1);
  int remapsize = (insize > outsize) ? insize : outsize;
  int elem_per_proc = insize*2;

  // Alloc the arrays
  int* displs = (int *)malloc(size*sizeof(int));
  int* scounts = (int *)malloc(size*sizeof(int));
  int* receive = (int *)malloc(size*sizeof(int));
  int* displs_gather = (int *)malloc(size*sizeof(int));
  int* scounts_gather = (int *)malloc(size*sizeof(int));
  int* receive_gather = (int *)malloc(size*sizeof(int));

  // Setup matrix
  int *modes_per_proc = (int *) malloc(sizeof(int)*size);
  modes_per_proc[rank] = (in_jhi-in_jlo+1) * (in_khi-in_klo+1);
  MPI_Allgather(&modes_per_proc[rank],1,MPI_INT,modes_per_proc,1,MPI_INT, MPI_COMM_WORLD);
  // Scattering & Gathering parameters
  int offset=0;
  for (int i=0; i<size; ++i) {
  	  scounts[i] = modes_per_proc[i]*nxd*2;
  	  receive[i] = scounts[i];
  	  displs[i] = offset;
  	  offset += scounts[i];
  }
  //printf("modes_ proc %d on rank %d\n", modes_per_proc[rank], rank);
  //printf("scoutn %d & disps %d on rank %d\n", scounts[rank], displs[rank], rank);


  /******************************************** Memory Alloc *******************************************/
  FFT_SCALAR *u = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *v = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *w = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *uu = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *uv = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *vv = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *vw = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *ww = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *uw = (FFT_SCALAR *) malloc(remapsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *sendbuf = (FFT_SCALAR *) malloc(sendsize*sizeof(FFT_SCALAR)*2);
  FFT_SCALAR *recvbuf = (FFT_SCALAR *) malloc(recvsize*sizeof(FFT_SCALAR)*2);

  if ((u||v||w||uu||uv||vv||vw||ww||uw||sendbuf||recvbuf) == NULL) {
	  perror(".:Error while allocating memory for remapping variables:.\n");
	  abort();
  }

  // Declare variables, on all procs, needed to Scatter data
  FFT_SCALAR *V, *U, *W;

  // Allocate mememory needed to Scatter data, only on the broadcaster
  // U
  U = (FFT_SCALAR*) malloc( nxd*ny*nzd*2* sizeof(FFT_SCALAR));
  if( U == NULL) {
	  perror(".:Error while allocatin broadcaster memory U:.\n");
	  abort();
  }
  if (rank == 0) read_data_and_apply_AA(nx, ny, nz, nxd, nzd, U, "u.dat");

  //Send chunks of array Velocity to all processors
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nxd, ny, nzd, U, u, 1);
  MPI_Barrier(MPI_COMM_WORLD);
  free(U);

  //V
  V = (FFT_SCALAR*) malloc( nxd*ny*nzd*2* sizeof(FFT_SCALAR));
  if( V == NULL) {
	  perror(".:Error while allocating broadcaster memory V:.\n");
	  abort();
  }
  if (rank == 0) read_data_and_apply_AA(nx, ny, nz, nxd, nzd, V, "v.dat");
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nxd, ny, nzd, V, v, 1);
  MPI_Barrier(MPI_COMM_WORLD);
  free(V);

  //W
  W = (FFT_SCALAR*) malloc( nxd*ny*nzd*2* sizeof(FFT_SCALAR));
  if( W == NULL) {
	  perror(".:Error while allocating broadcaster memory W:.\n");
	  abort();
  }
  if (rank == 0) read_data_and_apply_AA(nx, ny, nz, nxd, nzd, W, "w.dat");
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nxd, ny, nzd, W, w, 1);
  MPI_Barrier(MPI_COMM_WORLD);
  free(W);

  /************************************************ backward FFTs *********************************************/
  if (rank == 0) printf("Reading and Antialiasing completed...\nStarting Backward transformations...\n");
  // ------------------------------------------- Setup z-Transpose --------------------------------------------
  remap3d_create( remap_comm , &remap_zpencil);
  remap3d_setup( remap_zpencil,
      		  	  in_ilo,  in_ihi,  in_jlo, in_jhi,  in_klo,  in_khi,
				  out_ilo,  out_ihi,  out_jlo, out_jhi,  out_klo,  out_khi,
      			  nqty, permute, memoryflag, &sendsize, &recvsize);
  // -----------------------------------------------------------------------------------------------------------
  // Backward FFT#1
  //print_x_pencil(nxd, in_jlo, in_jhi, in_klo, u, rank, scounts[rank], 3);
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  double timer_b1 = 0.0;
  timer_b1 -= MPI_Wtime();
  b_FFT( u, elem_per_proc, i_length );
  b_FFT( v, elem_per_proc, i_length );
  b_FFT( w, elem_per_proc, i_length );
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_b1 += MPI_Wtime();


  // Transpose in z-pencil
  double timer_trasp_z = 0.0, TIMER_TRASP_z = 0.0;
  timer_trasp_z -= MPI_Wtime();
  remap3d_remap(remap_zpencil,u,u,sendbuf,recvbuf);
  remap3d_remap(remap_zpencil,v,v,sendbuf,recvbuf);
  remap3d_remap(remap_zpencil,w,w,sendbuf,recvbuf);
  MPI_Barrier(remap_comm); // @suppress("Symbol is not resolved")
  timer_trasp_z += MPI_Wtime();


  // Backward FFT#2
  double timer_b2 = 0.0;
  timer_b2 -= MPI_Wtime();
  b_FFT( u, elem_per_proc, k_length );
  b_FFT( v, elem_per_proc, k_length );
  b_FFT( w, elem_per_proc, k_length );
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_b2 += MPI_Wtime();


  //Finalize plan
  remap3d_destroy(remap_zpencil);
  //print_z_pencil( nz, in_ilo, in_ihi, in_jlo, u, rank, scounts[rank], 0);


  /************************************************ Convolutions *********************************************/
  // Operations
  double timer_conv = 0.0;
  timer_conv -= MPI_Wtime();
  for ( int i = 0; i < elem_per_proc; i++) {
	  uu[i] = u[i]*u[i];
	  uv[i] = u[i]*v[i];
	  vv[i] = v[i]*v[i];
	  vw[i] = v[i]*w[i];
	  ww[i] = w[i]*w[i];
	  uw[i] = u[i]*w[i];
  }
  timer_conv += MPI_Wtime();
  //print_z_pencil( nzd, out_ilo, out_ihi, out_jlo, uu, rank, scounts[rank], 1);
  if (rank == 0) printf("Completed\nStarting Forward transformations...\n");

  /************************************************ forward FFTs *********************************************/
  // ---------------------------------------- Setup x-Transpose -----------------------------------------
  remap3d_create( remap_comm , &remap_xpencil);
  permute = 1; 		// From z-contiguous to x-contiguous arrays
  remap3d_setup( remap_xpencil,
		  	  	  out_klo,  out_khi, out_ilo,  out_ihi,  out_jlo, out_jhi,
				  in_klo,  in_khi, in_ilo,  in_ihi,  in_jlo, in_jhi,
				  nqty, permute, memoryflag, &sendsize, &recvsize);
  // -----------------------------------------------------------------------------------------------------------
  // Forward FFT#1
  double timer_f1 = 0.0;
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f1 -= MPI_Wtime();
  //f_FFT( u, elem_per_proc, k_length );
  f_FFT( uu, elem_per_proc, k_length );
  f_FFT( uv, elem_per_proc, k_length );
  f_FFT( vv, elem_per_proc, k_length );
  f_FFT( vw, elem_per_proc, k_length );
  f_FFT( ww, elem_per_proc, k_length );
  f_FFT( uw, elem_per_proc, k_length );
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f1 += MPI_Wtime();


  // Transpose to x-pencil
  double timer_trasp_x = 0.0, TIMER_TRASP_x = 0.0;
  timer_trasp_x -= MPI_Wtime();
  //remap3d_remap(remap_xpencil,u,u,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,uu,uu,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,uv,uv,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,vv,vv,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,vw,vw,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,ww,ww,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,uw,uw,sendbuf,recvbuf);
  MPI_Barrier(remap_comm); // @suppress("Symbol is not resolved")
  timer_trasp_x += MPI_Wtime();


  // Forward FFT#2
  double timer_f2 = 0.0;
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f2 -= MPI_Wtime();
  //f_FFT( u, elem_per_proc, i_length );
  f_FFT( uu, elem_per_proc, i_length );
  f_FFT( uv, elem_per_proc, i_length );
  f_FFT( vv, elem_per_proc, i_length );
  f_FFT( vw, elem_per_proc, i_length );
  f_FFT( ww, elem_per_proc, i_length );
  f_FFT( uw, elem_per_proc, i_length );
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f2 += MPI_Wtime();

  // Finalize plan
  remap3d_destroy(remap_xpencil);
  free(recvbuf);	 free(sendbuf);

  // De-alias locally
  //print_x_pencil(nxd, in_jlo, in_jhi, in_klo, uu, rank, 2*nxd*(in_jhi-in_jlo+1)*(in_khi-in_klo+1), 2);
  double timer_aax = 0.0;
  timer_aax -= MPI_Wtime();
  //x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, u);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uu);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uv);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, vv);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, vw);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, ww);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uw);
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_aax += MPI_Wtime();
  if (rank == 0) printf("Completed\nStarting dealiasing operations\n");


  /********************************** Setup asymetric factors for scattering **********************************/
  // Setup matrix
  int modes_per_proc_scat[size], displs_scat[size], scounts_scat[size], receive_scat[size];
  for (int i = 0; i < size; i++){
	  modes_per_proc_scat[i] = 0;
	  displs_scat[i] = 0;
  }
  // Set modes per processor
  cores_handler( nx*nz, size, modes_per_proc_scat);
  // Scattering parameters
  offset=0;
  for (int i=0; i<size; ++i) {
	  scounts_scat[i] = modes_per_proc_scat[i]*ny*2;
	  receive_scat[i] = scounts_scat[i];
  	  displs_scat[i] = offset ;
  	  offset += modes_per_proc_scat[i] *ny*2;
  }


  /*********************************************** Modes cutting ********************************************/
  double TIMER_AA = 0.0;
  TIMER_AA -= MPI_Wtime();
  // Alloc memory for the global output
  FFT_SCALAR *UU, *UV, *VV, *VW, *WW, *UW;


  // Gather UU data on rank 0
  UU = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UU == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UU:.\n");
  		  abort();
  	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, UU, uu, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UU);
	  transpose_on_rank0( nx, ny, nz, UU);
  }
  else free(UU);
  MPI_Scatterv(UU, scounts_scat, displs_scat, MPI_DOUBLE, uu, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UU);


  // Gather UV data on rank 0
  UV = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UV == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UV:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, UV, uv, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UV);
  	  transpose_on_rank0( nx, ny, nz, UV);
  }
  else free(UV);
  MPI_Scatterv(UV, scounts_scat, displs_scat, MPI_DOUBLE, uv, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UV);


  // Gather VV data on rank 0
  VV = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( VV == NULL) {
  	  if (rank == 0) {
  		  perror(".:Error while allocating gather memory VV:.\n");
  		  abort();
  	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, VV, vv, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, VV);
	  transpose_on_rank0( nx, ny, nz, VV);
  }
  else free(VV);
  MPI_Scatterv(VV, scounts_scat, displs_scat, MPI_DOUBLE, vv, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(VV);


  // Gather VW data on rank 0
  VW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( VW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory VW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, VW, vw, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, VW);
  	  transpose_on_rank0( nx, ny, nz, VW);
  }
  else free(VW);
  MPI_Scatterv(VW, scounts_scat, displs_scat, MPI_DOUBLE, vw, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(VW);


  // Gather WW data on rank 0
  WW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( WW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory WW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, WW, ww, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, WW);
  	  transpose_on_rank0( nx, ny, nz, WW);
  }
  else free(WW);
  MPI_Scatterv(WW, scounts_scat, displs_scat, MPI_DOUBLE, ww, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(WW);


  // Gather UW data on rank 0
  UW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, UW, uw, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UW);
	  transpose_on_rank0( nx, ny, nz, UW);
  }
  else free(UW);
  MPI_Scatterv(UW, scounts_scat, displs_scat, MPI_DOUBLE, uw, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UW);

  TIMER_AA += MPI_Wtime();
  //print_y_pencil(nx, ny, nz, uu, rank, displs_scat[rank], scounts_scat[rank], 3);


  /************************************************ Print Stats *********************************************/
  // Gather all stats
  double TIMER_b1, TIMER_b2, TIMER_f1, TIMER_f2, TIMER_conv, TIMER_AAx;
  MPI_Allreduce(&timer_trasp_x, &TIMER_TRASP_x,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_trasp_z, &TIMER_TRASP_z,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_aax, &TIMER_AAx,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_b1, &TIMER_b1,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_b2, &TIMER_b2,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_f1, &TIMER_f1,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_f2, &TIMER_f2,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_conv, &TIMER_conv,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")

  // Print stats
  if (rank == 0) {
	  printf("\n-----------------------------------------------------------\n");
	  printf("%lgs employed to perform 2D FFT (backward) \n", TIMER_b1 +TIMER_b2);
	  printf("%lgs employed to transpose the array (z-pencil) \n", TIMER_TRASP_z);
	  printf("%lgs employed to perform 2D FFT (forward) \n", TIMER_f1 +TIMER_f2);
  	  printf("%lgs employed to transpose the array (x-pencil) \n", TIMER_TRASP_x);
  	  printf("%lgs employed to perform convolutions \n", TIMER_conv);
  	  printf("%lgs employed to de-alias locally in x direction\n", TIMER_AAx);
  	  printf("%lgs employed to gather, de-alias in z direction, transpose & scatter data \n", TIMER_AA);
  	  printf("-----------------------------------------------------------\n\n");
  	  printf("Process Ended\n");
  }

  displs_ = displs_scat[rank];
  scounts_ = scounts_scat[rank];
*>

WRITE
REAL entry_uu, entry_uv, entry_vv, entry_vw, entry_ww, entry_uw
INTEGER displs, scounts, counter=0, mode_y=0, modes_xz, start_mode_z, mode_z, end_mode_z, start_mode_x, mode_x, end_mode_x

!// Read starting modes
modes_xz = displs DIV (ny*2)
start_mode_z = modes_xz DIV nx;
start_mode_x = modes_xz - start_mode_z*nx;	
!// Take into account the negative modes
start_mode_z = start_mode_z - nz;		mode_z = start_mode_z;		mode_x = start_mode_x

!// Calculate ending mode_z & mode_x
modes_xz = (displs+scounts) DIV (ny*2)
end_mode_z = modes_xz DIV nx;
end_mode_x = modes_xz - end_mode_z*nx; 			
end_mode_z = end_mode_z -nz;
!// Allocate local array VV
ARRAY(0..nx, start_mode_z..end_mode_z,0..ny) OF MOMFLUX VV 


!//IF rank = 0 THEN
LOOP FOR counter= 0 TO scounts-1
	<*
	entry_uu_  =dnsdata_15move_data(uu,counter_);
	entry_uv_  =dnsdata_15move_data(uv,counter_);
	entry_vv_  =dnsdata_15move_data(vv,counter_);
	entry_vw_  =dnsdata_15move_data(vw,counter_);
	entry_ww_  =dnsdata_15move_data(ww,counter_);
	entry_uw_  =dnsdata_15move_data(uw,counter_);
 	counter_++;
	*> 
	VV(mode_x,mode_z,mode_y).uu.REAL= entry_uu;	VV(mode_x,mode_z,mode_y).vv.REAL= entry_vv;	VV(mode_x,mode_z,mode_y).ww.REAL= entry_ww;
	VV(mode_x,mode_z,mode_y).uv.REAL= entry_uv;	VV(mode_x,mode_z,mode_y).vw.REAL= entry_vw;	VV(mode_x,mode_z,mode_y).uw.REAL= entry_uw;	
	<*
	entry_uu_  =dnsdata_15move_data(uu,counter_);
	entry_uv_  =dnsdata_15move_data(uv,counter_);
	entry_vv_  =dnsdata_15move_data(vv,counter_);
	entry_vw_  =dnsdata_15move_data(vw,counter_);
	entry_ww_  =dnsdata_15move_data(ww,counter_);
	entry_uw_  =dnsdata_15move_data(uw,counter_);
	*> 
	VV(mode_x,mode_z,mode_y).uu.IMAG= entry_uu;	VV(mode_x,mode_z,mode_y).vv.IMAG= entry_vv;	VV(mode_x,mode_z,mode_y).ww.IMAG= entry_ww;
	VV(mode_x,mode_z,mode_y).uv.IMAG= entry_uv;	VV(mode_x,mode_z,mode_y).vw.IMAG= entry_vw;	VV(mode_x,mode_z,mode_y).uw.IMAG= entry_uw;
	!//WRITE mode_x, mode_z, mode_y	
	mode_y = mode_y + 1
	IF mode_y = ny THEN
		mode_y = 0
		mode_x = mode_x + 1
		IF mode_x = nx THEN 
			mode_x = 0
			mode_z = mode_z + 1
		END IF
	END IF
REPEAT LOOP
!//END IF

y_pencil_parser( VV, start_mode_x, end_mode_x, start_mode_z, end_mode_z, rank, 0)




