!USE rtchecks
WRITE
<*	/****************************************************************************
	 * 													      					*
	 * 				2D FFT with Pencil Decomposition in MPI Space				*
	 * 													      					*
	 ****************************************************************************
											     	   Author: Dr. Mirco Meazzo */


  /************************************************ backward FFTs *********************************************/
  if (rank == 0) printf("Reading and Antialiasing completed...\nStarting Backward transformations...\n");
  // ------------------------------------------- Setup z-Transpose --------------------------------------------
  remap3d_create( remap_comm , &remap_to_xpencil);
  remap3d_setup( remap_to_xpencil,
      		  	  z_ilo,  z_ihi,  z_jlo, z_jhi,  z_klo,  z_khi,
				  x_ilo,  x_ihi,  x_jlo, x_jhi,  x_klo,  x_khi,
      			  nqty, permute, memoryflag, &sendsize, &recvsize);
  // -----------------------------------------------------------------------------------------------------------
  // Apply AA in z direction
  
  z_aliasing( (z_ihi_s-z_ilo_s+1), (z_jhi-z_jlo+1), nz, nzd, u_, U);  
  free(U);
  // Backward FFT#1
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  double timer_b1 = 0.0;
  timer_b1 -= MPI_Wtime();	
  print_z_pencil( nzd, z_ilo_s, z_ihi_s, z_jlo_s, u_, rank, scounts[rank], 1);
*>

FFT_z( u, localdim, 1)
	
<*
  print_z_pencil( nzd, z_ilo, z_ihi, z_jlo, u_, rank, scounts[rank], 1);
  /*b_FFT( u, elem_per_proc, i_length );
  b_FFT( v, elem_per_proc, i_length );
  b_FFT( w, elem_per_proc, i_length );*/
  
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_b1 += MPI_Wtime();

  // Transpose in z-pencil
  double timer_trasp_z = 0.0, TIMER_TRASP_z = 0.0;
  timer_trasp_z -= MPI_Wtime();
  remap3d_remap(remap_to_xpencil,u_,u_,sendbuf,recvbuf);
  //remap3d_remap(remap_zpencil,v,v,sendbuf,recvbuf);
  //remap3d_remap(remap_zpencil,w,w,sendbuf,recvbuf);
  MPI_Barrier(remap_comm); // @suppress("Symbol is not resolved")
  timer_trasp_z += MPI_Wtime();

  // Backward FFT#2
  double timer_b2 = 0.0;
  timer_b2 -= MPI_Wtime();
  //print_z_pencil( nzd, x_ilo, x_ihi, x_jlo, u_, rank, scounts[rank], 0);
*>

!FFT_z( u, localdim, 1)

<*

 /* b_FFT( u, elem_per_proc, k_length );
  b_FFT( v, elem_per_proc, k_length );
  b_FFT( w, elem_per_proc, k_length );*/
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_b2 += MPI_Wtime();


  //Finalize plan
  remap3d_destroy(remap_to_xpencil);
  //print_z_pencil( nzd, x_ilo, x_ihi, x_jlo, u_, rank, scounts[rank], 0);


  /************************************************ Convolutions *********************************************/
  // Operations
  double timer_conv = 0.0;
  timer_conv -= MPI_Wtime();
*>
LOOP FOR i=0 TO localdim
	uu[i] = u[i]*u[i]
REPEAT LOOP
<*

 /* for ( int i = 0; i < elem_per_proc; i++) {
	  uu_[i] = u_[i]*u_[i];
	printf("uu = %g\n",uu_[i]);
	  uv[i] = u_[i]*v[i];
	  vv[i] = v[i]*v[i];
	  vw[i] = v[i]*w[i];
	  ww[i] = w[i]*w[i];
	  uw[i] = u_[i]*w[i];
  } */
  timer_conv += MPI_Wtime();
  //print_z_pencil( nzd, z_ilo, z_ihi, z_jlo, uu, rank, scounts[rank], 1);
  if (rank == 0) printf("Completed\nStarting Forward transformations...\n");

  /************************************************ forward FFTs *********************************************/
  // ---------------------------------------- Setup x-Transpose -----------------------------------------
  remap3d_create( remap_comm , &remap_to_zpencil);
  permute = 2; 		// From x-contiguous to z-contiguous arrays
  remap3d_setup( remap_to_zpencil,
		  	  	  x_klo,  x_khi, x_ilo,  x_ihi,  x_jlo, x_jhi,
				  z_klo,  z_khi, z_ilo,  z_ihi,  z_jlo, z_jhi,
				  nqty, permute, memoryflag, &sendsize, &recvsize);
  // -----------------------------------------------------------------------------------------------------------
  // Forward FFT#1
  double timer_f1 = 0.0;
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f1 -= MPI_Wtime();
*>
!FFT_z( u, localdim, -1)
<*
//print_z_pencil( nzd, z_ilo, z_ihi, z_jlo, u_, rank, scounts[rank], 1);
  //f_FFT( u, elem_per_proc, k_length );
 /* f_FFT( uu, elem_per_proc, k_length );
  f_FFT( uv, elem_per_proc, k_length );
  f_FFT( vv, elem_per_proc, k_length );
  f_FFT( vw, elem_per_proc, k_length );
  f_FFT( ww, elem_per_proc, k_length );
  f_FFT( uw, elem_per_proc, k_length );*/
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f1 += MPI_Wtime();


  // Transpose to x-pencil
  double timer_trasp_x = 0.0, TIMER_TRASP_x = 0.0;
  timer_trasp_x -= MPI_Wtime();
  remap3d_remap(remap_to_zpencil,u_,u_,sendbuf,recvbuf);
 /* remap3d_remap(remap_xpencil,uu_,uu_,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,uv,uv,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,vv,vv,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,vw,vw,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,ww,ww,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,uw,uw,sendbuf,recvbuf);  */
  MPI_Barrier(remap_comm); // @suppress("Symbol is not resolved")
  timer_trasp_x += MPI_Wtime();
//print_x_pencil(nxd, x_jlo, x_jhi, x_klo, u_, rank, scounts[rank], 0);

  // Forward FFT#2
  double timer_f2 = 0.0;
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f2 -= MPI_Wtime();
*>
!FFT_x( u, localdim, -1)
<*
//print_x_pencil(nxd, x_jlo, x_jhi, x_klo, u_, rank, scounts[rank], 0);
  //f_FFT( u, elem_per_proc, i_length );
 /* f_FFT( uu, elem_per_proc, i_length );
  f_FFT( uv, elem_per_proc, i_length );
  f_FFT( vv, elem_per_proc, i_length );
  f_FFT( vw, elem_per_proc, i_length );
  f_FFT( ww, elem_per_proc, i_length );
  f_FFT( uw, elem_per_proc, i_length );*/
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f2 += MPI_Wtime();

  // Finalize plan
  remap3d_destroy(remap_to_zpencil);
  free(recvbuf);	 free(sendbuf);

  // De-alias locally
  //print_x_pencil(nxd, x_jlo, x_jhi, x_klo, u_, rank, 2*nxd*(x_jhi-x_jlo+1)*(x_khi-x_klo+1), 0);
  double timer_aax = 0.0;
  timer_aax -= MPI_Wtime();
  /*x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, u);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uu_);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uv);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, vv);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, vw);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, ww);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uw);	*/
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_aax += MPI_Wtime();
  if (rank == 0) printf("Completed\nStarting dealiasing operations\n");


  /*********************************************** Modes cutting ********************************************/
  double TIMER_AA = 0.0;
  TIMER_AA -= MPI_Wtime();
  // Alloc memory for the global output
  FFT_SCALAR *UU, *UV, *VV, *VW, *WW, *UW;

/*
  // Gather UU data on rank 0
  UU = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UU == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UU:.\n");
  		  abort();
  	  }
  }
  Alltoall( rank, size, x_jlo, x_jhi, x_klo, x_khi, nx, ny, nzd, UU, uu_, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UU);
	  transpose_on_rank0( nx, ny, nz, UU);
  }
  else free(UU);
  MPI_Scatterv(UU, scounts_scat, displs_scat, MPI_DOUBLE, uu_, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UU);


  // Gather UV data on rank 0
  UV = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UV == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UV:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, x_jlo, x_jhi, x_klo, x_khi, nx, ny, nzd, UV, uv, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UV);
  	  transpose_on_rank0( nx, ny, nz, UV);
  }
  else free(UV);
  MPI_Scatterv(UV, scounts_scat, displs_scat, MPI_DOUBLE, uv, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UV);


  // Gather VV data on rank 0
  VV = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( VV == NULL) {
  	  if (rank == 0) {
  		  perror(".:Error while allocating gather memory VV:.\n");
  		  abort();
  	  }
  }
  Alltoall( rank, size, x_jlo, x_jhi, x_klo, x_khi, nx, ny, nzd, VV, vv, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, VV);
	  transpose_on_rank0( nx, ny, nz, VV);
  }
  else free(VV);
  MPI_Scatterv(VV, scounts_scat, displs_scat, MPI_DOUBLE, vv, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(VV);


  // Gather VW data on rank 0
  VW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( VW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory VW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, x_jlo, x_jhi, x_klo, x_khi, nx, ny, nzd, VW, vw, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, VW);
  	  transpose_on_rank0( nx, ny, nz, VW);
  }
  else free(VW);
  MPI_Scatterv(VW, scounts_scat, displs_scat, MPI_DOUBLE, vw, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(VW);


  // Gather WW data on rank 0
  WW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( WW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory WW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, x_jlo, x_jhi, x_klo, x_khi, nx, ny, nzd, WW, ww, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, WW);
  	  transpose_on_rank0( nx, ny, nz, WW);
  }
  else free(WW);
  MPI_Scatterv(WW, scounts_scat, displs_scat, MPI_DOUBLE, ww, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(WW);


  // Gather UW data on rank 0
  UW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, x_jlo, x_jhi, x_klo, x_khi, nx, ny, nzd, UW, uw, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UW);
	  transpose_on_rank0( nx, ny, nz, UW);
  }
  else free(UW);
  MPI_Scatterv(UW, scounts_scat, displs_scat, MPI_DOUBLE, uw, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UW);

  TIMER_AA += MPI_Wtime();
  //print_y_pencil(nx, ny, nz, u_read, rank, displs_scat[rank], scounts_scat[rank], 0);


  /************************************************ Print Stats *********************************************/
  // Gather all stats
  double TIMER_b1, TIMER_b2, TIMER_f1, TIMER_f2, TIMER_conv, TIMER_AAx;
  MPI_Allreduce(&timer_trasp_x, &TIMER_TRASP_x,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_trasp_z, &TIMER_TRASP_z,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_aax, &TIMER_AAx,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_b1, &TIMER_b1,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_b2, &TIMER_b2,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_f1, &TIMER_f1,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_f2, &TIMER_f2,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_conv, &TIMER_conv,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")

  // Print stats
  if (rank == 0) {
	  printf("\n-----------------------------------------------------------\n");
	  printf("%lgs employed to perform 2D FFT (backward) \n", TIMER_b1 +TIMER_b2);
	  printf("%lgs employed to transpose the array (z-pencil) \n", TIMER_TRASP_z);
	  printf("%lgs employed to perform 2D FFT (forward) \n", TIMER_f1 +TIMER_f2);
  	  printf("%lgs employed to transpose the array (x-pencil) \n", TIMER_TRASP_x);
  	  printf("%lgs employed to perform convolutions \n", TIMER_conv);
  	  printf("%lgs employed to de-alias locally in x direction\n", TIMER_AAx);
  	  printf("%lgs employed to gather, de-alias in z direction, transpose & scatter data \n", TIMER_AA);
  	  printf("-----------------------------------------------------------\n\n");
  	  printf("Process Ended\n");
  }

 // displs_ = displs_scat[rank];
 // scounts_ = scounts_scat[rank];
*>
!(
WRITE
REAL entry_uu, entry_uv, entry_vv, entry_vw, entry_ww, entry_uw, entry_u, entry_v, entry_w
INTEGER displs, scounts, counter=0, mode_y=0, modes_xz, start_mode_z, mode_z, end_mode_z, start_mode_x, mode_x, end_mode_x

!// Read starting modes
modes_xz = displs DIV ((ny+3)*2)
start_mode_z = modes_xz DIV (nx+1);
start_mode_x = modes_xz - start_mode_z*(nx+1);	
!// Take into account the negative modes
start_mode_z = start_mode_z - nz;

!// Calculate ending mode_z & mode_x
modes_xz = (displs+scounts) DIV ((ny+3)*2)
end_mode_z = modes_xz DIV (nx+1);
end_mode_x = modes_xz - end_mode_z*(nx+1); 			
end_mode_z = end_mode_z -nz;

INTEGER loop_end_mode_x = nx; INTEGER loop_start_mode_x = start_mode_x
!// Allocate and fill the local array VV
ARRAY(0..nx, start_mode_z..end_mode_z,-1..ny+1) OF MOMFLUX VV 
ARRAY(0..nx, start_mode_z..end_mode_z,-1..ny+1) OF VELOCITY V 
LOOP FOR mode_z = start_mode_z TO end_mode_z
	IF mode_z = end_mode_z THEN loop_end_mode_x = end_mode_x
	LOOP FOR mode_x = loop_start_mode_x TO loop_end_mode_x	
		LOOP FOR mode_y = -1 TO ny+1	
		<*	entry_uu_  =dnsdata_10move_data(uu_,counter_);
			entry_uv_  =dnsdata_10move_data(uv,counter_);
			entry_vv_  =dnsdata_10move_data(vv,counter_);
			entry_vw_  =dnsdata_10move_data(vw,counter_);
			entry_ww_  =dnsdata_10move_data(ww,counter_);
			entry_uw_  =dnsdata_10move_data(uw,counter_);
			entry_u_  =dnsdata_10move_data(u_read,counter_);
			entry_v_  =dnsdata_10move_data(v_read,counter_);
			entry_w_  =dnsdata_10move_data(w_read,counter_);
 			counter_++;		*> 
			VV(mode_x,mode_z,mode_y).uu.REAL= entry_uu;	VV(mode_x,mode_z,mode_y).vv.REAL= entry_vv;	VV(mode_x,mode_z,mode_y).ww.REAL= entry_ww;
			VV(mode_x,mode_z,mode_y).uv.REAL= entry_uv;	VV(mode_x,mode_z,mode_y).vw.REAL= entry_vw;	VV(mode_x,mode_z,mode_y).uw.REAL= entry_uw;
			V(mode_x,mode_z,mode_y).u.REAL= entry_u;	V(mode_x,mode_z,mode_y).v.REAL= entry_v;	V(mode_x,mode_z,mode_y).w.REAL= entry_w;
		<*	entry_uu_  =dnsdata_10move_data(uu_,counter_);
			entry_uv_  =dnsdata_10move_data(uv,counter_);
			entry_vv_  =dnsdata_10move_data(vv,counter_);
			entry_vw_  =dnsdata_10move_data(vw,counter_);
			entry_ww_  =dnsdata_10move_data(ww,counter_);
			entry_uw_  =dnsdata_10move_data(uw,counter_);
			entry_u_  =dnsdata_10move_data(u_read,counter_);
			entry_v_  =dnsdata_10move_data(v_read,counter_);
			entry_w_  =dnsdata_10move_data(w_read,counter_);
			counter_++;		*> 
			VV(mode_x,mode_z,mode_y).uu.IMAG= entry_uu;	VV(mode_x,mode_z,mode_y).vv.IMAG= entry_vv;	VV(mode_x,mode_z,mode_y).ww.IMAG= entry_ww;
			VV(mode_x,mode_z,mode_y).uv.IMAG= entry_uv;	VV(mode_x,mode_z,mode_y).vw.IMAG= entry_vw;	VV(mode_x,mode_z,mode_y).uw.IMAG= entry_uw;
			V(mode_x,mode_z,mode_y).u.IMAG= entry_u;	V(mode_x,mode_z,mode_y).v.IMAG= entry_v;	V(mode_x,mode_z,mode_y).w.IMAG= entry_w;
		REPEAT LOOP
	REPEAT LOOP
	loop_start_mode_x = 0
REPEAT LOOP

!)




