!USE rtchecks
WRITE
<*	/****************************************************************************
	 * 													      					*
	 * 				2D FFT with Pencil Decomposition in MPI Space				*
	 * 													      					*
	 ****************************************************************************
											     	   Author: Dr. Mirco Meazzo */


  /************************************************ backward FFTs *********************************************/
  if (rank == 0) printf("Reading and Antialiasing completed...\nStarting Backward transformations...\n");
  // ------------------------------------------- Setup z-Transpose --------------------------------------------
  remap3d_create( remap_comm , &remap_zpencil);
  remap3d_setup( remap_zpencil,
      		  	  in_ilo,  in_ihi,  in_jlo, in_jhi,  in_klo,  in_khi,
				  out_ilo,  out_ihi,  out_jlo, out_jhi,  out_klo,  out_khi,
      			  nqty, permute, memoryflag, &sendsize, &recvsize);
  // -----------------------------------------------------------------------------------------------------------
  // Backward FFT#1
  //print_x_pencil(nxd, in_jlo, in_jhi, in_klo, u_, rank, scounts[rank], 0);
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  double timer_b1 = 0.0;
  timer_b1 -= MPI_Wtime();	
*>

b_FFT_x( u, localdim)

	
<*
  //print_x_pencil(nxd, in_jlo, in_jhi, in_klo, u_, rank, scounts[rank], 2);
  /*b_FFT( u, elem_per_proc, i_length );
  b_FFT( v, elem_per_proc, i_length );
  b_FFT( w, elem_per_proc, i_length );*/
  
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_b1 += MPI_Wtime();


  // Transpose in z-pencil
  double timer_trasp_z = 0.0, TIMER_TRASP_z = 0.0;
  timer_trasp_z -= MPI_Wtime();
  remap3d_remap(remap_zpencil,u_,u_,sendbuf,recvbuf);
  remap3d_remap(remap_zpencil,v,v,sendbuf,recvbuf);
  remap3d_remap(remap_zpencil,w,w,sendbuf,recvbuf);
  MPI_Barrier(remap_comm); // @suppress("Symbol is not resolved")
  timer_trasp_z += MPI_Wtime();


  // Backward FFT#2
  double timer_b2 = 0.0;
  timer_b2 -= MPI_Wtime();
 /* b_FFT( u, elem_per_proc, k_length );
  b_FFT( v, elem_per_proc, k_length );
  b_FFT( w, elem_per_proc, k_length );*/
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_b2 += MPI_Wtime();


  //Finalize plan
  remap3d_destroy(remap_zpencil);
  //print_z_pencil( nzd, in_ilo, in_ihi, in_jlo, u, rank, scounts[rank], 0);


  /************************************************ Convolutions *********************************************/
  // Operations
  double timer_conv = 0.0;
  timer_conv -= MPI_Wtime();
  for ( int i = 0; i < elem_per_proc; i++) {
	  uu[i] = u_[i]*u_[i];
	  uv[i] = u_[i]*v[i];
	  vv[i] = v[i]*v[i];
	  vw[i] = v[i]*w[i];
	  ww[i] = w[i]*w[i];
	  uw[i] = u_[i]*w[i];
  }
  timer_conv += MPI_Wtime();
  //print_z_pencil( nzd, out_ilo, out_ihi, out_jlo, uu, rank, scounts[rank], 1);
  if (rank == 0) printf("Completed\nStarting Forward transformations...\n");

  /************************************************ forward FFTs *********************************************/
  // ---------------------------------------- Setup x-Transpose -----------------------------------------
  remap3d_create( remap_comm , &remap_xpencil);
  permute = 1; 		// From z-contiguous to x-contiguous arrays
  remap3d_setup( remap_xpencil,
		  	  	  out_klo,  out_khi, out_ilo,  out_ihi,  out_jlo, out_jhi,
				  in_klo,  in_khi, in_ilo,  in_ihi,  in_jlo, in_jhi,
				  nqty, permute, memoryflag, &sendsize, &recvsize);
  // -----------------------------------------------------------------------------------------------------------
  // Forward FFT#1
  double timer_f1 = 0.0;
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f1 -= MPI_Wtime();
  //f_FFT( u, elem_per_proc, k_length );
 /* f_FFT( uu, elem_per_proc, k_length );
  f_FFT( uv, elem_per_proc, k_length );
  f_FFT( vv, elem_per_proc, k_length );
  f_FFT( vw, elem_per_proc, k_length );
  f_FFT( ww, elem_per_proc, k_length );
  f_FFT( uw, elem_per_proc, k_length );*/
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f1 += MPI_Wtime();


  // Transpose to x-pencil
  double timer_trasp_x = 0.0, TIMER_TRASP_x = 0.0;
  timer_trasp_x -= MPI_Wtime();
  //remap3d_remap(remap_xpencil,u,u,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,uu,uu,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,uv,uv,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,vv,vv,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,vw,vw,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,ww,ww,sendbuf,recvbuf);
  remap3d_remap(remap_xpencil,uw,uw,sendbuf,recvbuf);
  MPI_Barrier(remap_comm); // @suppress("Symbol is not resolved")
  timer_trasp_x += MPI_Wtime();


  // Forward FFT#2
  double timer_f2 = 0.0;
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f2 -= MPI_Wtime();
  //f_FFT( u, elem_per_proc, i_length );
 /* f_FFT( uu, elem_per_proc, i_length );
  f_FFT( uv, elem_per_proc, i_length );
  f_FFT( vv, elem_per_proc, i_length );
  f_FFT( vw, elem_per_proc, i_length );
  f_FFT( ww, elem_per_proc, i_length );
  f_FFT( uw, elem_per_proc, i_length );*/
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_f2 += MPI_Wtime();

  // Finalize plan
  remap3d_destroy(remap_xpencil);
  free(recvbuf);	 free(sendbuf);

  // De-alias locally
  //print_x_pencil(nxd, in_jlo, in_jhi, in_klo, uu, rank, 2*nxd*(in_jhi-in_jlo+1)*(in_khi-in_klo+1), 2);
  double timer_aax = 0.0;
  timer_aax -= MPI_Wtime();
  //x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, u);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uu);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uv);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, vv);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, vw);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, ww);
  x_dealiasing( scounts[rank], modes_per_proc[rank], nx, nxd, uw);
  MPI_Barrier( MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  timer_aax += MPI_Wtime();
  if (rank == 0) printf("Completed\nStarting dealiasing operations\n");


  /*********************************************** Modes cutting ********************************************/
  double TIMER_AA = 0.0;
  TIMER_AA -= MPI_Wtime();
  // Alloc memory for the global output
  FFT_SCALAR *UU, *UV, *VV, *VW, *WW, *UW;


  // Gather UU data on rank 0
  UU = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UU == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UU:.\n");
  		  abort();
  	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, UU, uu, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UU);
	  transpose_on_rank0( nx, ny, nz, UU);
  }
  else free(UU);
  MPI_Scatterv(UU, scounts_scat, displs_scat, MPI_DOUBLE, uu, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UU);


  // Gather UV data on rank 0
  UV = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UV == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UV:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, UV, uv, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UV);
  	  transpose_on_rank0( nx, ny, nz, UV);
  }
  else free(UV);
  MPI_Scatterv(UV, scounts_scat, displs_scat, MPI_DOUBLE, uv, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UV);


  // Gather VV data on rank 0
  VV = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( VV == NULL) {
  	  if (rank == 0) {
  		  perror(".:Error while allocating gather memory VV:.\n");
  		  abort();
  	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, VV, vv, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, VV);
	  transpose_on_rank0( nx, ny, nz, VV);
  }
  else free(VV);
  MPI_Scatterv(VV, scounts_scat, displs_scat, MPI_DOUBLE, vv, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(VV);


  // Gather VW data on rank 0
  VW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( VW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory VW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, VW, vw, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, VW);
  	  transpose_on_rank0( nx, ny, nz, VW);
  }
  else free(VW);
  MPI_Scatterv(VW, scounts_scat, displs_scat, MPI_DOUBLE, vw, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(VW);


  // Gather WW data on rank 0
  WW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( WW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory WW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, WW, ww, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, WW);
  	  transpose_on_rank0( nx, ny, nz, WW);
  }
  else free(WW);
  MPI_Scatterv(WW, scounts_scat, displs_scat, MPI_DOUBLE, ww, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(WW);


  // Gather UW data on rank 0
  UW = (FFT_SCALAR*) malloc( nx*ny*nzd*2* sizeof(FFT_SCALAR));
  if( UW == NULL) {
	  if (rank == 0) {
		  perror(".:Error while allocating gather memory UW:.\n");
		  abort();
	  }
  }
  Alltoall( rank, size, in_jlo, in_jhi, in_klo, in_khi, nx, ny, nzd, UW, uw, -1);
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")
  if (rank == 0) {
	  z_dealiasing( nx, ny, nz, nxd, nzd, UW);
	  transpose_on_rank0( nx, ny, nz, UW);
  }
  else free(UW);
  MPI_Scatterv(UW, scounts_scat, displs_scat, MPI_DOUBLE, uw, receive_scat[rank] , MPI_DOUBLE, 0, MPI_COMM_WORLD);
  MPI_Barrier(MPI_COMM_WORLD);
  if (rank == 0) free(UW);

  TIMER_AA += MPI_Wtime();
  //print_y_pencil(nx, ny, nz, u_read, rank, displs_scat[rank], scounts_scat[rank], 0);


  /************************************************ Print Stats *********************************************/
  // Gather all stats
  double TIMER_b1, TIMER_b2, TIMER_f1, TIMER_f2, TIMER_conv, TIMER_AAx;
  MPI_Allreduce(&timer_trasp_x, &TIMER_TRASP_x,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_trasp_z, &TIMER_TRASP_z,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_aax, &TIMER_AAx,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_b1, &TIMER_b1,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_b2, &TIMER_b2,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_f1, &TIMER_f1,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_f2, &TIMER_f2,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Allreduce(&timer_conv, &TIMER_conv,1,MPI_DOUBLE,MPI_MAX,remap_comm); // @suppress("Symbol is not resolved")
  MPI_Barrier(MPI_COMM_WORLD); // @suppress("Symbol is not resolved")

  // Print stats
  if (rank == 0) {
	  printf("\n-----------------------------------------------------------\n");
	  printf("%lgs employed to perform 2D FFT (backward) \n", TIMER_b1 +TIMER_b2);
	  printf("%lgs employed to transpose the array (z-pencil) \n", TIMER_TRASP_z);
	  printf("%lgs employed to perform 2D FFT (forward) \n", TIMER_f1 +TIMER_f2);
  	  printf("%lgs employed to transpose the array (x-pencil) \n", TIMER_TRASP_x);
  	  printf("%lgs employed to perform convolutions \n", TIMER_conv);
  	  printf("%lgs employed to de-alias locally in x direction\n", TIMER_AAx);
  	  printf("%lgs employed to gather, de-alias in z direction, transpose & scatter data \n", TIMER_AA);
  	  printf("-----------------------------------------------------------\n\n");
  	  printf("Process Ended\n");
  }

  displs_ = displs_scat[rank];
  scounts_ = scounts_scat[rank];
*>

WRITE
REAL entry_uu, entry_uv, entry_vv, entry_vw, entry_ww, entry_uw, entry_u, entry_v, entry_w
INTEGER displs, scounts, counter=0, mode_y=0, modes_xz, start_mode_z, mode_z, end_mode_z, start_mode_x, mode_x, end_mode_x

!// Read starting modes
modes_xz = displs DIV ((ny+3)*2)
start_mode_z = modes_xz DIV (nx+1);
start_mode_x = modes_xz - start_mode_z*(nx+1);	
!// Take into account the negative modes
start_mode_z = start_mode_z - nz;

!// Calculate ending mode_z & mode_x
modes_xz = (displs+scounts) DIV ((ny+3)*2)
end_mode_z = modes_xz DIV (nx+1);
end_mode_x = modes_xz - end_mode_z*(nx+1); 			
end_mode_z = end_mode_z -nz;

INTEGER loop_end_mode_x = nx; INTEGER loop_start_mode_x = start_mode_x
!// Allocate and fill the local array VV
ARRAY(0..nx, start_mode_z..end_mode_z,-1..ny+1) OF MOMFLUX VV 
ARRAY(0..nx, start_mode_z..end_mode_z,-1..ny+1) OF VELOCITY V 
LOOP FOR mode_z = start_mode_z TO end_mode_z
	IF mode_z = end_mode_z THEN loop_end_mode_x = end_mode_x
	LOOP FOR mode_x = loop_start_mode_x TO loop_end_mode_x	
		LOOP FOR mode_y = -1 TO ny+1	
		<*	entry_uu_  =dnsdata_10move_data(uu,counter_);
			entry_uv_  =dnsdata_10move_data(uv,counter_);
			entry_vv_  =dnsdata_10move_data(vv,counter_);
			entry_vw_  =dnsdata_10move_data(vw,counter_);
			entry_ww_  =dnsdata_10move_data(ww,counter_);
			entry_uw_  =dnsdata_10move_data(uw,counter_);
			entry_u_  =dnsdata_10move_data(u_read,counter_);
			entry_v_  =dnsdata_10move_data(v_read,counter_);
			entry_w_  =dnsdata_10move_data(w_read,counter_);
 			counter_++;		*> 
			VV(mode_x,mode_z,mode_y).uu.REAL= entry_uu;	VV(mode_x,mode_z,mode_y).vv.REAL= entry_vv;	VV(mode_x,mode_z,mode_y).ww.REAL= entry_ww;
			VV(mode_x,mode_z,mode_y).uv.REAL= entry_uv;	VV(mode_x,mode_z,mode_y).vw.REAL= entry_vw;	VV(mode_x,mode_z,mode_y).uw.REAL= entry_uw;
			V(mode_x,mode_z,mode_y).u.REAL= entry_u;	V(mode_x,mode_z,mode_y).v.REAL= entry_v;	V(mode_x,mode_z,mode_y).w.REAL= entry_w;
		<*	entry_uu_  =dnsdata_10move_data(uu,counter_);
			entry_uv_  =dnsdata_10move_data(uv,counter_);
			entry_vv_  =dnsdata_10move_data(vv,counter_);
			entry_vw_  =dnsdata_10move_data(vw,counter_);
			entry_ww_  =dnsdata_10move_data(ww,counter_);
			entry_uw_  =dnsdata_10move_data(uw,counter_);
			entry_u_  =dnsdata_10move_data(u_read,counter_);
			entry_v_  =dnsdata_10move_data(v_read,counter_);
			entry_w_  =dnsdata_10move_data(w_read,counter_);
			counter_++;		*> 
			VV(mode_x,mode_z,mode_y).uu.IMAG= entry_uu;	VV(mode_x,mode_z,mode_y).vv.IMAG= entry_vv;	VV(mode_x,mode_z,mode_y).ww.IMAG= entry_ww;
			VV(mode_x,mode_z,mode_y).uv.IMAG= entry_uv;	VV(mode_x,mode_z,mode_y).vw.IMAG= entry_vw;	VV(mode_x,mode_z,mode_y).uw.IMAG= entry_uw;
			V(mode_x,mode_z,mode_y).u.IMAG= entry_u;	V(mode_x,mode_z,mode_y).v.IMAG= entry_v;	V(mode_x,mode_z,mode_y).w.IMAG= entry_w;
		REPEAT LOOP
	REPEAT LOOP
	loop_start_mode_x = 0
REPEAT LOOP






